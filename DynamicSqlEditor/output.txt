.\App.config
---
ï»¿<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.8" />
    </startup>
</configuration>

---
.\DynamicSqlEditor.csproj
---
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{10B3F88D-EF99-4E28-97D4-E88BFB16CE3B}</ProjectGuid>
    <OutputType>WinExe</OutputType>
    <RootNamespace>DynamicSqlEditor</RootNamespace>
    <AssemblyName>DynamicSqlEditor</AssemblyName>
    <TargetFrameworkVersion>v4.8</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
    <Deterministic>true</Deterministic>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Deployment" />
    <Reference Include="System.Drawing" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Windows.Forms" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Common\Constants.cs" />
    <Compile Include="Common\ControlFactory.cs" />
    <Compile Include="Common\FileLogger.cs" />
    <Compile Include="Common\GlobalExceptionHandler.cs" />
    <Compile Include="Common\SqlParameterHelper.cs" />
    <Compile Include="Configuration\ConfigurationManager.cs" />
    <Compile Include="Configuration\DslParser.cs" />
    <Compile Include="Configuration\Models\ActionButtonDefinition.cs" />
    <Compile Include="Configuration\Models\AppConfig.cs" />
    <Compile Include="Configuration\Models\ConnectionConfig.cs" />
    <Compile Include="Configuration\Models\DetailFormFieldDefinition.cs" />
    <Compile Include="Configuration\Models\FilterDefinition.cs" />
    <Compile Include="Configuration\Models\FKLookupDefinition.cs" />
    <Compile Include="Configuration\Models\GlobalConfig.cs" />
    <Compile Include="Configuration\Models\RelatedChildDefinition.cs" />
    <Compile Include="Configuration\Models\TableConfig.cs" />
    <Compile Include="Core\CrudManager.cs" />
    <Compile Include="Core\DataViewManager.cs" />
    <Compile Include="Core\StateManager.cs" />
    <Compile Include="DataAccess\ConcurrencyHandler.cs" />
    <Compile Include="DataAccess\DatabaseManager.cs" />
    <Compile Include="DataAccess\DataPager.cs" />
    <Compile Include="DataAccess\QueryBuilder.cs" />
    <Compile Include="Form1.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="Form1.Designer.cs">
      <DependentUpon>Form1.cs</DependentUpon>
    </Compile>
    <Compile Include="Models\DataRowWrapper.cs" />
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="Schema\Models\ColumnSchema.cs" />
    <Compile Include="Schema\Models\ForeignKeySchema.cs" />
    <Compile Include="Schema\Models\PrimaryKeySchema.cs" />
    <Compile Include="Schema\Models\TableSchema.cs" />
    <Compile Include="Schema\SchemaFilter.cs" />
    <Compile Include="Schema\SchemaProvider.cs" />
    <Compile Include="UI\Builders\ActionButtonBuilder.cs" />
    <Compile Include="UI\Builders\DetailFormBuilder.cs" />
    <Compile Include="UI\Builders\FilterUIBuilder.cs" />
    <Compile Include="UI\Builders\RelatedTabsBuilder.cs" />
    <Compile Include="UI\Controls\NullableDateTimePicker.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Include="UI\Controls\PagingControl.cs">
      <SubType>UserControl</SubType>
    </Compile>
    <Compile Include="UI\DataViewForm.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="UI\DataViewForm.Designer.cs">
      <DependentUpon>DataViewForm.cs</DependentUpon>
    </Compile>
    <Compile Include="UI\Dialogs\ConfirmationDialog.cs" />
    <Compile Include="UI\Dialogs\FilterInputDialog.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="UI\MainForm.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="UI\MainForm.Designer.cs">
      <DependentUpon>MainForm.cs</DependentUpon>
    </Compile>
    <EmbeddedResource Include="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
      <SubType>Designer</SubType>
    </EmbeddedResource>
    <Compile Include="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
    <None Include="Properties\Settings.settings">
      <Generator>SettingsSingleFileGenerator</Generator>
      <LastGenOutput>Settings.Designer.cs</LastGenOutput>
    </None>
    <Compile Include="Properties\Settings.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Settings.settings</DependentUpon>
      <DesignTimeSharedInput>True</DesignTimeSharedInput>
    </Compile>
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
</Project>

---
.\DynamicSqlEditor.csproj.user
---
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ProjectView>ShowAllFiles</ProjectView>
  </PropertyGroup>
</Project>

---
.\Form1.Designer.cs
---
ï»¿namespace DynamicSqlEditor
{
    partial class Form1
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(800, 450);
            this.Text = "Form1";
        }

        #endregion
    }
}



---
.\Form1.cs
---
ï»¿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace DynamicSqlEditor
{
    public partial class Form1 : Form
    {
        public Form1()
        {
            InitializeComponent();
        }
    }
}


---
.\Program.cs
---
using System;
using System.Windows.Forms;
using DynamicSqlEditor.Common;
using DynamicSqlEditor.UI;

namespace DynamicSqlEditor
{
    static class Program
    {
        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);

            GlobalExceptionHandler.Initialize();
            FileLogger.Initialize("Logs");

            try
            {
                Application.Run(new MainForm());
            }
            catch (Exception ex)
            {
                FileLogger.Error("Unhandled exception in Main.", ex);
                MessageBox.Show($"An unexpected error occurred: {ex.Message}\nPlease check the log file for details.", "Application Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
            finally
            {
                FileLogger.Shutdown();
            }
        }
    }
}

---
.\output.txt
---


---
.\Common\Constants.cs
---
namespace DynamicSqlEditor.Common
{
    public static class Constants
    {
        public const string DefaultConfigFileName = "AppConfig.dsl";
        public const string ConfigDirectory = "Config";
        public const string LogDirectory = "Logs";
        public const int DefaultQueryTimeout = 60;
        public const string DefaultDateTimeFormat = "yyyy-MM-dd HH:mm:ss";
        public const string DefaultDateFormat = "yyyy-MM-dd";
        public const string DirtyFlagIndicator = "*";

        public const string WherePlaceholder = "{WHERE}";
        public const string OrderByPlaceholder = "{ORDERBY}";
        public const string PagingPlaceholder = "{PAGING}";

        public const string DefaultFKHeuristic = "Name,Description,Title,*ID";

        public static class Sections
        {
            public const string Connection = "Connection";
            public const string Global = "Global";
            public const string TablePrefix = "Table:";
        }

        public static class Keys
        {
            public const string ConnectionString = "ConnectionString";
            public const string QueryTimeout = "QueryTimeout";
            public const string IncludeSchemas = "IncludeSchemas";
            public const string ExcludeTables = "ExcludeTables";
            public const string DefaultFKDisplayHeuristic = "DefaultFKDisplayHeuristic";
            public const string DisableCustomActionExecution = "DisableCustomActionExecution";
            public const string CustomSelectQuery = "CustomSelectQuery";
            public const string FilterPrefix = "Filter.";
            public const string FilterDefault = "Filter.Default";
            public const string DetailFormFieldPrefix = "DetailFormField.";
            public const string FKLookupPrefix = "FKLookup.";
            public const string ActionButtonPrefix = "ActionButton.";
            public const string RelatedChildPrefix = "RelatedChild.";
            public const string DefaultSortColumn = "DefaultSortColumn";
            public const string DefaultSortDirection = "DefaultSortDirection";
        }

        public static class Attributes
        {
            public const string Label = "Label";
            public const string WhereClause = "WhereClause";
            public const string RequiresInput = "RequiresInput";
            public const string FilterName = "FilterName";
            public const string Order = "Order";
            public const string ReadOnly = "ReadOnly";
            public const string Visible = "Visible";
            public const string ControlType = "ControlType";
            public const string ReferencedTable = "ReferencedTable";
            public const string DisplayColumn = "DisplayColumn";
            public const string ValueColumn = "ValueColumn";
            public const string ReferencedColumn = "ReferencedColumn";
            public const string Command = "Command";
            public const string RequiresSelection = "RequiresSelection";
            public const string SuccessMessage = "SuccessMessage";
            public const string ChildTable = "ChildTable";
            public const string ChildFKColumn = "ChildFKColumn";
            public const string ParentPKColumn = "ParentPKColumn";
            public const string ChildFilter = "ChildFilter";
        }

        public static class ControlTypes
        {
            public const string Default = "Default";
            public const string TextBox = "TextBox";
            public const string TextBoxMultiLine = "TextBoxMultiLine";
            public const string ComboBox = "ComboBox";
            public const string CheckBox = "CheckBox";
            public const string DateTimePicker = "DateTimePicker";
            public const string Label = "Label";
        }
    }
}

---
.\Common\ControlFactory.cs
---
using System;
using System.Windows.Forms;
using DynamicSqlEditor.Configuration.Models;
using DynamicSqlEditor.Schema.Models;
using DynamicSqlEditor.UI.Controls;

namespace DynamicSqlEditor.Common
{
    public static class ControlFactory
    {
        public static Control CreateControl(ColumnSchema column, DetailFormFieldDefinition fieldConfig)
        {
            string controlType = fieldConfig?.ControlType ?? Constants.ControlTypes.Default;

            if (controlType == Constants.ControlTypes.Label || (fieldConfig?.ReadOnly ?? false))
            {
                return new Label { AutoSize = true, Padding = new Padding(3, 6, 3, 3) };
            }

            if (controlType == Constants.ControlTypes.CheckBox || (controlType == Constants.ControlTypes.Default && column.DataType.ToLower() == "bit"))
            {
                return new CheckBox { AutoSize = true };
            }

            if (controlType == Constants.ControlTypes.DateTimePicker || (controlType == Constants.ControlTypes.Default && IsDateType(column.DataType)))
            {
                if (column.IsNullable)
                {
                    return new NullableDateTimePicker { Format = DateTimePickerFormat.Custom, CustomFormat = Constants.DefaultDateTimeFormat, Width = 180 };
                }
                else
                {
                    return new DateTimePicker { Format = DateTimePickerFormat.Custom, CustomFormat = Constants.DefaultDateTimeFormat, Width = 180 };
                }
            }

            if (controlType == Constants.ControlTypes.ComboBox)
            {
                 return new ComboBox { DropDownStyle = ComboBoxStyle.DropDownList, Width = 180 };
            }

            if (controlType == Constants.ControlTypes.TextBoxMultiLine || (controlType == Constants.ControlTypes.Default && IsLongTextType(column.DataType, column.MaxLength)))
            {
                return new TextBox { Multiline = true, ScrollBars = ScrollBars.Vertical, Height = 60, Width = 180 };
            }

            return new TextBox { Width = 180 };
        }

        public static Label CreateLabel(ColumnSchema column, DetailFormFieldDefinition fieldConfig)
        {
            string labelText = fieldConfig?.Label ?? column.ColumnName;
            return new Label { Text = labelText + ":", AutoSize = true, TextAlign = System.Drawing.ContentAlignment.MiddleRight };
        }

        public static CheckBox CreateIsNullCheckBox(ColumnSchema column)
        {
            if (!column.IsNullable || column.DataType.ToLower() == "bit") return null;

            return new CheckBox { Text = "Is Null", AutoSize = true, Tag = "IsNullCheckBox" };
        }

        private static bool IsDateType(string dataType)
        {
            string lowerType = dataType.ToLower();
            return lowerType.Contains("date") || lowerType.Contains("time");
        }

        private static bool IsLongTextType(string dataType, int? maxLength)
        {
            string lowerType = dataType.ToLower();
            return lowerType.Contains("text") || lowerType.Contains("xml") || (lowerType.Contains("char") && (maxLength == -1 || maxLength > 255));
        }
    }
}

---
.\Common\FileLogger.cs
---
using System;
using System.IO;
using System.Text;
using System.Threading;
using System.Collections.Concurrent;
using System.Threading.Tasks;

namespace DynamicSqlEditor.Common
{
    public static class FileLogger
    {
        private static string _logDirectory;
        private static string _logFilePath;
        private static BlockingCollection<string> _logQueue = new BlockingCollection<string>();
        private static CancellationTokenSource _cancellationTokenSource = new CancellationTokenSource();
        private static Task _loggingTask;
        private static bool _initialized = false;

        public static void Initialize(string logDirectory)
        {
            if (_initialized) return;

            try
            {
                _logDirectory = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, logDirectory);
                if (!Directory.Exists(_logDirectory))
                {
                    Directory.CreateDirectory(_logDirectory);
                }
                _logFilePath = Path.Combine(_logDirectory, $"Log_{DateTime.Now:yyyyMMdd_HHmmss}.log");

                _loggingTask = Task.Run(() => ProcessLogQueue(_cancellationTokenSource.Token));
                _initialized = true;
                Info("Logger initialized.");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Failed to initialize logger: {ex.Message}");
            }
        }

        public static void Info(string message) => Log("INFO", message);
        public static void Warning(string message) => Log("WARN", message);
        public static void Error(string message, Exception ex = null)
        {
            var sb = new StringBuilder();
            sb.AppendLine(message);
            if (ex != null)
            {
                sb.AppendLine($"Exception: {ex.GetType().Name}");
                sb.AppendLine($"Message: {ex.Message}");
                sb.AppendLine($"Stack Trace: {ex.StackTrace}");
                if (ex.InnerException != null)
                {
                    sb.AppendLine($"--- Inner Exception ---");
                    sb.AppendLine($"Exception: {ex.InnerException.GetType().Name}");
                    sb.AppendLine($"Message: {ex.InnerException.Message}");
                    sb.AppendLine($"Stack Trace: {ex.InnerException.StackTrace}");
                    sb.AppendLine($"--- End Inner Exception ---");
                }
            }
            Log("ERROR", sb.ToString());
        }

        private static void Log(string level, string message)
        {
            if (!_initialized || _logQueue.IsAddingCompleted) return;
            string logEntry = $"{DateTime.Now:yyyy-MM-dd HH:mm:ss.fff} [{level}] {message}";
            _logQueue.Add(logEntry);
        }

        private static void ProcessLogQueue(CancellationToken token)
        {
            try
            {
                using (var writer = new StreamWriter(_logFilePath, true, Encoding.UTF8))
                {
                    writer.AutoFlush = true;
                    foreach (var logEntry in _logQueue.GetConsumingEnumerable(token))
                    {
                        writer.WriteLine(logEntry);
                        Console.WriteLine(logEntry); // Also write to console for debugging
                    }
                }
            }
            catch (OperationCanceledException)
            {
                // Expected when shutting down
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error in logging thread: {ex.Message}");
            }
        }

        public static void Shutdown()
        {
            if (!_initialized) return;
            Info("Logger shutting down.");
            _logQueue.CompleteAdding();
            _cancellationTokenSource.Cancel();
            _loggingTask?.Wait(TimeSpan.FromSeconds(5)); // Wait briefly for queue to flush
            _initialized = false;
        }
    }
}

---
.\Common\GlobalExceptionHandler.cs
---
using System;
using System.Threading;
using System.Windows.Forms;

namespace DynamicSqlEditor.Common
{
    public static class GlobalExceptionHandler
    {
        public static void Initialize()
        {
            Application.ThreadException += Application_ThreadException;
            AppDomain.CurrentDomain.UnhandledException += CurrentDomain_UnhandledException;
        }

        private static void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e)
        {
            var exception = e.ExceptionObject as Exception;
            string message = "An unhandled non-UI exception occurred.";
            if (exception != null)
            {
                message = $"An unhandled non-UI exception occurred: {exception.Message}";
                FileLogger.Error(message, exception);
            }
            else
            {
                message = $"An unhandled non-UI exception occurred: {e.ExceptionObject}";
                FileLogger.Error(message);
            }

            MessageBox.Show(message + "\nPlease check the log file for details.", "Critical Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
        }

        private static void Application_ThreadException(object sender, ThreadExceptionEventArgs e)
        {
            string message = $"An unhandled UI exception occurred: {e.Exception.Message}";
            FileLogger.Error(message, e.Exception);
            MessageBox.Show(message + "\nPlease check the log file for details.", "UI Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
        }
    }
}

---
.\Common\SqlParameterHelper.cs
---
using System;
using System.Data;
using System.Data.SqlClient;

namespace DynamicSqlEditor.Common
{
    public static class SqlParameterHelper
    {
        public static SqlParameter CreateParameter(string name, object value, SqlDbType? dbType = null)
        {
            var parameter = new SqlParameter(name, value ?? DBNull.Value);
            if (dbType.HasValue)
            {
                parameter.SqlDbType = dbType.Value;
            }
            return parameter;
        }

        public static SqlParameter CreateParameter(string name, object value, SqlDbType dbType, int size)
        {
            var parameter = new SqlParameter(name, dbType, size)
            {
                Value = value ?? DBNull.Value
            };
            return parameter;
        }

        public static SqlParameter CreateOutputParameter(string name, SqlDbType dbType, int size = -1)
        {
            var parameter = new SqlParameter(name, dbType)
            {
                Direction = ParameterDirection.Output
            };
            if (size > -1)
            {
                parameter.Size = size;
            }
            return parameter;
        }
    }
}

---
.\Configuration\ConfigurationManager.cs
---
// File: DynamicSqlEditor/Configuration/ConfigurationManager.cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Windows.Forms; // <-- Add this using directive for SortOrder
using DynamicSqlEditor.Common;
using DynamicSqlEditor.Configuration.Models;

namespace DynamicSqlEditor.Configuration
{
    public class ConfigurationManager
    {
        private readonly DslParser _parser = new DslParser();
        public AppConfig CurrentConfig { get; private set; } = new AppConfig();
        public List<string> ParsingErrors { get; private set; } = new List<string>();

        public TableConfig GetTableConfig(string schemaName, string tableName)
        {
            string fullTableName = $"{schemaName}.{tableName}";
            // Use CurrentConfig which holds the loaded configuration
            CurrentConfig.Tables.TryGetValue(fullTableName, out var config);
            // Return a new default config if not found, ensuring it's never null
            return config ?? new TableConfig(fullTableName);
        }

        public bool LoadConfiguration(string databaseName = null)
        {
            ParsingErrors.Clear();
            // Create new instances to ensure merging doesn't carry over old state incorrectly
            CurrentConfig = new AppConfig();
            _parser.ClearInternalState(); // Add a method to clear parser state if needed

            string baseConfigPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, Constants.ConfigDirectory, Constants.DefaultConfigFileName);
            string dbSpecificConfigPath = null;
            if (!string.IsNullOrEmpty(databaseName))
            {
                dbSpecificConfigPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, Constants.ConfigDirectory, $"{databaseName}.dsl");
            }

            // Load base first, then merge DB specific over it
            bool baseLoaded = LoadAndParseFile(baseConfigPath, false); // Don't merge yet

            // Create a new parser instance or clear state before parsing the second file
            // to ensure settings are merged correctly if the DslParser keeps state.
            // Assuming DslParser's Parse method handles merging or overwriting correctly when called multiple times.
            // If not, the logic needs adjustment here to load into separate DslParser instances and merge manually.

            bool dbSpecificLoaded = false;
            if (dbSpecificConfigPath != null && File.Exists(dbSpecificConfigPath))
            {
                // Parse the DB-specific file, letting the parser merge/overwrite
                dbSpecificLoaded = LoadAndParseFile(dbSpecificConfigPath, true); // Indicate merge
            }

            if (!baseLoaded && !dbSpecificLoaded)
            {
                FileLogger.Warning($"No configuration files found or loaded ({baseConfigPath}, {dbSpecificConfigPath}). Using defaults.");
                // Allow continuing with defaults, but log it.
            }

            ProcessParsedData();

            if (ParsingErrors.Any())
            {
                FileLogger.Warning("Configuration loading completed with errors:");
                foreach (var error in ParsingErrors)
                {
                    FileLogger.Warning($"- {error}");
                }
            }
            else
            {
                FileLogger.Info("Configuration loaded successfully.");
            }

            // Return true only if no critical errors (ignore warnings like duplicates)
            return !ParsingErrors.Any(e => !e.Contains("Duplicate key") && !e.StartsWith("Unknown key") && !e.StartsWith("Unknown configuration section"));
        }

        // Modified LoadAndParseFile to potentially handle merging state if parser doesn't
        private bool LoadAndParseFile(string filePath, bool merge)
        {
            if (!File.Exists(filePath)) return false;

            FileLogger.Info($"Attempting to load configuration from: {filePath}");
            // If DslParser doesn't merge internally, create a temp parser here
            // DslParser tempParser = new DslParser();
            // bool success = tempParser.Parse(filePath);
            // Merge tempParser._sections into _parser._sections manually here if needed
            bool success = _parser.Parse(filePath); // Assuming Parse handles merging/overwriting
            ParsingErrors.AddRange(_parser.Errors);
            return success;
        }

        private void ProcessParsedData()
        {
            // Ensure base structures exist
            if (CurrentConfig.Connection == null) CurrentConfig.Connection = new ConnectionConfig();
            if (CurrentConfig.Global == null) CurrentConfig.Global = new GlobalConfig();

            foreach (var sectionPair in _parser.GetAllSections())
            {
                string sectionName = sectionPair.Key;
                var settings = sectionPair.Value;

                try
                {
                    if (sectionName.Equals(Constants.Sections.Connection, StringComparison.OrdinalIgnoreCase))
                    {
                        ProcessConnectionSection(settings);
                    }
                    else if (sectionName.Equals(Constants.Sections.Global, StringComparison.OrdinalIgnoreCase))
                    {
                        ProcessGlobalSection(settings);
                    }
                    else if (sectionName.StartsWith(Constants.Sections.TablePrefix, StringComparison.OrdinalIgnoreCase))
                    {
                        string tableName = sectionName.Substring(Constants.Sections.TablePrefix.Length);
                        ProcessTableSection(tableName, settings);
                    }
                    else
                    {
                        ParsingErrors.Add($"Unknown configuration section: [{sectionName}]");
                    }
                }
                catch (Exception ex)
                {
                    string errorMsg = $"Error processing section [{sectionName}]: {ex.Message}";
                    ParsingErrors.Add(errorMsg);
                    FileLogger.Error(errorMsg, ex);
                }
            }

            // Apply global defaults if not set after processing all files
            if (!CurrentConfig.Global.DefaultFKDisplayHeuristic.Any())
            {
                CurrentConfig.Global.DefaultFKDisplayHeuristic = SplitCsv(Constants.DefaultFKHeuristic);
            }
        }

        private void ProcessConnectionSection(Dictionary<string, string> settings)
        {
            // Use existing or create new if null
            CurrentConfig.Connection = CurrentConfig.Connection ?? new ConnectionConfig();

            if (settings.TryGetValue(Constants.Keys.ConnectionString, out var connectionString))
                CurrentConfig.Connection.ConnectionString = connectionString;

            if (settings.TryGetValue(Constants.Keys.QueryTimeout, out var timeoutStr) && int.TryParse(timeoutStr, out int timeout))
            {
                CurrentConfig.Connection.QueryTimeout = timeout;
            }
            // Ensure default timeout if not specified
            else if (CurrentConfig.Connection.QueryTimeout <= 0)
            {
                CurrentConfig.Connection.QueryTimeout = Constants.DefaultQueryTimeout;
            }
        }

        private void ProcessGlobalSection(Dictionary<string, string> settings)
        {
            CurrentConfig.Global = CurrentConfig.Global ?? new GlobalConfig();

            if (settings.TryGetValue(Constants.Keys.IncludeSchemas, out var includeSchemas))
                CurrentConfig.Global.IncludeSchemas = SplitCsv(includeSchemas);

            if (settings.TryGetValue(Constants.Keys.ExcludeTables, out var excludeTables))
                CurrentConfig.Global.ExcludeTables = SplitCsv(excludeTables);

            if (settings.TryGetValue(Constants.Keys.DefaultFKDisplayHeuristic, out var fkHeuristic))
                CurrentConfig.Global.DefaultFKDisplayHeuristic = SplitCsv(fkHeuristic);
            // Default heuristic applied later in ProcessParsedData if still empty


            if (settings.TryGetValue(Constants.Keys.DisableCustomActionExecution, out var disableStr) && bool.TryParse(disableStr, out bool disable))
            {
                CurrentConfig.Global.DisableCustomActionExecution = disable;
            }
        }

        private void ProcessTableSection(string tableName, Dictionary<string, string> settings)
        {
            if (!CurrentConfig.Tables.TryGetValue(tableName, out var tableConfig))
            {
                tableConfig = new TableConfig(tableName);
                CurrentConfig.Tables[tableName] = tableConfig;
            }

            foreach (var kvp in settings)
            {
                string key = kvp.Key;
                string value = kvp.Value;

                try
                {
                    if (key.Equals(Constants.Keys.CustomSelectQuery, StringComparison.OrdinalIgnoreCase))
                    {
                        tableConfig.CustomSelectQuery = value;
                    }
                    else if (key.Equals(Constants.Keys.DefaultSortColumn, StringComparison.OrdinalIgnoreCase))
                    {
                        tableConfig.DefaultSortColumn = value;
                    }
                    else if (key.Equals(Constants.Keys.DefaultSortDirection, StringComparison.OrdinalIgnoreCase))
                    {
                        // Line ~171 where the error occurred
                        if (Enum.TryParse<SortOrder>(value, true, out var direction))
                        {
                            tableConfig.DefaultSortDirection = direction;
                        }
                        else
                        {
                            ParsingErrors.Add($"Invalid DefaultSortDirection '{value}' for table '{tableName}'. Use Ascending or Descending.");
                        }
                    }
                    else if (key.Equals(Constants.Keys.FilterDefault, StringComparison.OrdinalIgnoreCase))
                    {
                        var attrs = DslParser.ParseAttributes(value);
                        if (attrs.TryGetValue(Constants.Attributes.FilterName, out var filterName))
                        {
                            tableConfig.DefaultFilterName = filterName;
                        }
                        else
                        {
                            ParsingErrors.Add($"Missing '{Constants.Attributes.FilterName}' attribute for '{key}' in table '{tableName}'.");
                        }
                    }
                    else if (key.StartsWith(Constants.Keys.FilterPrefix, StringComparison.OrdinalIgnoreCase))
                    {
                        string filterName = key.Substring(Constants.Keys.FilterPrefix.Length);
                        if (filterName.Equals("Default", StringComparison.OrdinalIgnoreCase)) continue; // Skip Filter.Default here
                        var filter = ParseFilterDefinition(filterName, value, tableName);
                        if (filter != null) tableConfig.Filters[filterName] = filter;
                    }
                    else if (key.StartsWith(Constants.Keys.DetailFormFieldPrefix, StringComparison.OrdinalIgnoreCase))
                    {
                        string columnName = key.Substring(Constants.Keys.DetailFormFieldPrefix.Length);
                        var field = ParseDetailFormFieldDefinition(columnName, value, tableName);
                        if (field != null) tableConfig.DetailFormFields[columnName] = field;
                    }
                    else if (key.StartsWith(Constants.Keys.FKLookupPrefix, StringComparison.OrdinalIgnoreCase))
                    {
                        string fkColumnName = key.Substring(Constants.Keys.FKLookupPrefix.Length);
                        var lookup = ParseFKLookupDefinition(fkColumnName, value, tableName);
                        if (lookup != null) tableConfig.FKLookups[fkColumnName] = lookup;
                    }
                    else if (key.StartsWith(Constants.Keys.ActionButtonPrefix, StringComparison.OrdinalIgnoreCase))
                    {
                        string buttonName = key.Substring(Constants.Keys.ActionButtonPrefix.Length);
                        var button = ParseActionButtonDefinition(buttonName, value, tableName);
                        if (button != null) tableConfig.ActionButtons[buttonName] = button;
                    }
                    else if (key.StartsWith(Constants.Keys.RelatedChildPrefix, StringComparison.OrdinalIgnoreCase))
                    {
                        string relationName = key.Substring(Constants.Keys.RelatedChildPrefix.Length);
                        var related = ParseRelatedChildDefinition(relationName, value, tableName);
                        if (related != null) tableConfig.RelatedChildren[relationName] = related;
                    }
                    else
                    {
                        ParsingErrors.Add($"Unknown key '{key}' in section '[{Constants.Sections.TablePrefix}{tableName}]'.");
                    }
                }
                catch (Exception ex)
                {
                    string errorMsg = $"Error processing key '{key}' in section '[{Constants.Sections.TablePrefix}{tableName}]': {ex.Message}";
                    ParsingErrors.Add(errorMsg);
                    FileLogger.Error(errorMsg, ex);
                }
            }
        }

        private FilterDefinition ParseFilterDefinition(string name, string value, string tableName)
        {
            var attrs = DslParser.ParseAttributes(value);
            if (!attrs.TryGetValue(Constants.Attributes.Label, out var label))
            {
                ParsingErrors.Add($"Missing '{Constants.Attributes.Label}' attribute for Filter '{name}' in table '{tableName}'.");
                return null;
            }
            if (!attrs.TryGetValue(Constants.Attributes.WhereClause, out var whereClause))
            {
                ParsingErrors.Add($"Missing '{Constants.Attributes.WhereClause}' attribute for Filter '{name}' in table '{tableName}'.");
                return null;
            }
            attrs.TryGetValue(Constants.Attributes.RequiresInput, out var requiresInput);

            return new FilterDefinition
            {
                Name = name,
                Label = label,
                WhereClause = whereClause,
                RequiresInput = requiresInput
            };
        }

        private DetailFormFieldDefinition ParseDetailFormFieldDefinition(string columnName, string value, string tableName)
        {
            var attrs = DslParser.ParseAttributes(value);
            var field = new DetailFormFieldDefinition { ColumnName = columnName };

            if (attrs.TryGetValue(Constants.Attributes.Order, out var orderStr) && int.TryParse(orderStr, out int order))
            {
                field.Order = order;
            }
            attrs.TryGetValue(Constants.Attributes.Label, out var label);
            field.Label = label; // Can be null

            if (attrs.TryGetValue(Constants.Attributes.ReadOnly, out var readOnlyStr) && bool.TryParse(readOnlyStr, out bool readOnly))
            {
                field.ReadOnly = readOnly;
            }
            if (attrs.TryGetValue(Constants.Attributes.Visible, out var visibleStr) && bool.TryParse(visibleStr, out bool visible))
            {
                field.Visible = visible;
            }
            attrs.TryGetValue(Constants.Attributes.ControlType, out var controlType);
            field.ControlType = controlType; // Can be null

            return field;
        }

        private FKLookupDefinition ParseFKLookupDefinition(string fkColumnName, string value, string tableName)
        {
            var attrs = DslParser.ParseAttributes(value);
            if (!attrs.TryGetValue(Constants.Attributes.ReferencedTable, out var referencedTable))
            {
                ParsingErrors.Add($"Missing '{Constants.Attributes.ReferencedTable}' attribute for FKLookup '{fkColumnName}' in table '{tableName}'.");
                return null;
            }
            if (!attrs.TryGetValue(Constants.Attributes.DisplayColumn, out var displayColumn))
            {
                ParsingErrors.Add($"Missing '{Constants.Attributes.DisplayColumn}' attribute for FKLookup '{fkColumnName}' in table '{tableName}'.");
                return null;
            }
            attrs.TryGetValue(Constants.Attributes.ValueColumn, out var valueColumn);
            attrs.TryGetValue(Constants.Attributes.ReferencedColumn, out var referencedColumn);

            return new FKLookupDefinition
            {
                FKColumnName = fkColumnName,
                ReferencedTable = referencedTable,
                DisplayColumn = displayColumn,
                ValueColumn = valueColumn, // Can be null
                ReferencedColumn = referencedColumn // Can be null
            };
        }

        private ActionButtonDefinition ParseActionButtonDefinition(string buttonName, string value, string tableName)
        {
            var attrs = DslParser.ParseAttributes(value);
            if (!attrs.TryGetValue(Constants.Attributes.Label, out var label))
            {
                ParsingErrors.Add($"Missing '{Constants.Attributes.Label}' attribute for ActionButton '{buttonName}' in table '{tableName}'.");
                return null;
            }
            if (!attrs.TryGetValue(Constants.Attributes.Command, out var command))
            {
                ParsingErrors.Add($"Missing '{Constants.Attributes.Command}' attribute for ActionButton '{buttonName}' in table '{tableName}'.");
                return null;
            }
            bool requiresSelection = true;
            if (attrs.TryGetValue(Constants.Attributes.RequiresSelection, out var reqSelStr) && bool.TryParse(reqSelStr, out bool reqSel))
            {
                requiresSelection = reqSel;
            }
            attrs.TryGetValue(Constants.Attributes.SuccessMessage, out var successMessage);

            return new ActionButtonDefinition
            {
                Name = buttonName,
                Label = label,
                Command = command,
                RequiresSelection = requiresSelection,
                SuccessMessage = successMessage
            };
        }

        private RelatedChildDefinition ParseRelatedChildDefinition(string relationName, string value, string tableName)
        {
            var attrs = DslParser.ParseAttributes(value);
            if (!attrs.TryGetValue(Constants.Attributes.Label, out var label))
            {
                ParsingErrors.Add($"Missing '{Constants.Attributes.Label}' attribute for RelatedChild '{relationName}' in table '{tableName}'.");
                return null;
            }
            if (!attrs.TryGetValue(Constants.Attributes.ChildTable, out var childTable))
            {
                ParsingErrors.Add($"Missing '{Constants.Attributes.ChildTable}' attribute for RelatedChild '{relationName}' in table '{tableName}'.");
                return null;
            }
            if (!attrs.TryGetValue(Constants.Attributes.ChildFKColumn, out var childFkColumn))
            {
                ParsingErrors.Add($"Missing '{Constants.Attributes.ChildFKColumn}' attribute for RelatedChild '{relationName}' in table '{tableName}'.");
                return null;
            }
            attrs.TryGetValue(Constants.Attributes.ParentPKColumn, out var parentPkColumn);
            attrs.TryGetValue(Constants.Attributes.ChildFilter, out var childFilter);

            return new RelatedChildDefinition
            {
                RelationName = relationName,
                Label = label,
                ChildTable = childTable,
                ChildFKColumn = childFkColumn,
                ParentPKColumn = parentPkColumn, // Can be null
                ChildFilter = childFilter // Can be null
            };
        }

        private List<string> SplitCsv(string csv)
        {
            if (string.IsNullOrWhiteSpace(csv))
            {
                return new List<string>();
            }
            return csv.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries)
                      .Select(s => s.Trim())
                      .Where(s => !string.IsNullOrEmpty(s))
                      .ToList();
        }

        // Helper for DslParser state clearing if needed
        public void ClearParserState()
        {
            _parser.ClearInternalState(); // Assuming DslParser has this method
        }
    }

    // Add this extension method to DslParser if it doesn't have a clear method
    public static class DslParserExtensions
    {
        // Add this method if DslParser needs explicit clearing
        public static void ClearInternalState(this DslParser parser)
        {
            // Access internal fields via reflection if necessary and allowed,
            // or preferably add a public Clear method to DslParser itself.
            // Example (if _sections and _errors were public/internal):
            // parser._sections.Clear();
            // parser._errors.Clear();

            // If they are private, reflection is needed (less ideal):
            var sectionsField = typeof(DslParser).GetField("_sections", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);
            var errorsField = typeof(DslParser).GetField("_errors", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);

            if (sectionsField?.GetValue(parser) is IDictionary<string, Dictionary<string, string>> sections)
            {
                sections.Clear();
            }
            if (errorsField?.GetValue(parser) is List<string> errors)
            {
                errors.Clear();
            }
        }
    }
}

---
.\Configuration\DslParser.cs
---
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using DynamicSqlEditor.Common;
using DynamicSqlEditor.Configuration.Models;

namespace DynamicSqlEditor.Configuration
{
    public class DslParser
    {
        private readonly Dictionary<string, Dictionary<string, string>> _sections = new Dictionary<string, Dictionary<string, string>>(StringComparer.OrdinalIgnoreCase);
        private readonly List<string> _errors = new List<string>();

        public IEnumerable<string> Errors => _errors;

        public bool Parse(string filePath)
        {
            _sections.Clear();
            _errors.Clear();

            if (!File.Exists(filePath))
            {
                _errors.Add($"Configuration file not found: {filePath}");
                return false;
            }

            string currentSection = null;
            int lineNumber = 0;

            try
            {
                using (var reader = new StreamReader(filePath))
                {
                    string line;
                    while ((line = reader.ReadLine()) != null)
                    {
                        lineNumber++;
                        line = line.Trim();

                        if (string.IsNullOrWhiteSpace(line) || line.StartsWith("#"))
                        {
                            continue;
                        }

                        if (line.StartsWith("[") && line.EndsWith("]"))
                        {
                            currentSection = line.Substring(1, line.Length - 2).Trim();
                            if (!_sections.ContainsKey(currentSection))
                            {
                                _sections[currentSection] = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                            }
                        }
                        else if (currentSection != null)
                        {
                            int equalsIndex = line.IndexOf('=');
                            if (equalsIndex > 0)
                            {
                                string key = line.Substring(0, equalsIndex).Trim();
                                string value = line.Substring(equalsIndex + 1).Trim();

                                if (_sections[currentSection].ContainsKey(key))
                                {
                                    _errors.Add($"Duplicate key '{key}' in section '[{currentSection}]' at line {lineNumber}. Using last value.");
                                }
                                _sections[currentSection][key] = value;
                            }
                            else
                            {
                                _errors.Add($"Malformed key-value pair in section '[{currentSection}]' at line {lineNumber}: {line}");
                            }
                        }
                        else
                        {
                            _errors.Add($"Key-value pair found outside of any section at line {lineNumber}: {line}");
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                _errors.Add($"Error reading or parsing file '{filePath}': {ex.Message}");
                FileLogger.Error($"Error parsing DSL file '{filePath}'", ex);
                return false;
            }

            return !_errors.Any(e => !e.Contains("Duplicate key")); // Allow duplicate key warnings
        }

        public Dictionary<string, string> GetSection(string sectionName)
        {
            _sections.TryGetValue(sectionName, out var section);
            return section ?? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
        }

        public IEnumerable<KeyValuePair<string, Dictionary<string, string>>> GetAllSections()
        {
            return _sections;
        }

        public static Dictionary<string, string> ParseAttributes(string valueString)
        {
            var attributes = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
            if (string.IsNullOrWhiteSpace(valueString)) return attributes;

            var regex = new Regex(@"(?<key>\w+)\s*=\s*(?:""(?<value>[^""]*)""|(?<value>[^,]+))", RegexOptions.IgnoreCase);
            var matches = regex.Matches(valueString);

            foreach (Match match in matches)
            {
                string key = match.Groups["key"].Value.Trim();
                string value = match.Groups["value"].Value.Trim();
                attributes[key] = value;
            }
            return attributes;
        }
    }
}

---
.\Configuration\Models\ActionButtonDefinition.cs
---
namespace DynamicSqlEditor.Configuration.Models
{
    public class ActionButtonDefinition
    {
        public string Name { get; set; }
        public string Label { get; set; }
        public string Command { get; set; }
        public bool RequiresSelection { get; set; } = true;
        public string SuccessMessage { get; set; }
    }
}

---
.\Configuration\Models\AppConfig.cs
---
using System.Collections.Generic;

namespace DynamicSqlEditor.Configuration.Models
{
    public class AppConfig
    {
        public ConnectionConfig Connection { get; set; } = new ConnectionConfig();
        public GlobalConfig Global { get; set; } = new GlobalConfig();
        public Dictionary<string, TableConfig> Tables { get; set; } = new Dictionary<string, TableConfig>(System.StringComparer.OrdinalIgnoreCase);
    }
}

---
.\Configuration\Models\ConnectionConfig.cs
---
using DynamicSqlEditor.Common;

namespace DynamicSqlEditor.Configuration.Models
{
    public class ConnectionConfig
    {
        public string ConnectionString { get; set; }
        public int QueryTimeout { get; set; } = Constants.DefaultQueryTimeout;
    }
}

---
.\Configuration\Models\DetailFormFieldDefinition.cs
---
namespace DynamicSqlEditor.Configuration.Models
{
    public class DetailFormFieldDefinition
    {
        public string ColumnName { get; set; }
        public int Order { get; set; } = 999;
        public string Label { get; set; }
        public bool? ReadOnly { get; set; } // Nullable bool to distinguish between not set and set to false
        public bool? Visible { get; set; } // Nullable bool
        public string ControlType { get; set; } // e.g., TextBox, ComboBox, DateTimePicker, Label
    }
}

---
.\Configuration\Models\FKLookupDefinition.cs
---
namespace DynamicSqlEditor.Configuration.Models
{
    public class FKLookupDefinition
    {
        public string FKColumnName { get; set; }
        public string ReferencedTable { get; set; } // Schema.TableName
        public string DisplayColumn { get; set; }
        public string ValueColumn { get; set; } // Optional, defaults to PK of ReferencedTable
        public string ReferencedColumn { get; set; } // Optional, defaults to ValueColumn or PK
    }
}

---
.\Configuration\Models\FilterDefinition.cs
---
namespace DynamicSqlEditor.Configuration.Models
{
    public class FilterDefinition
    {
        public string Name { get; set; }
        public string Label { get; set; }
        public string WhereClause { get; set; }
        public string RequiresInput { get; set; } // Format: "ParamName:LookupType" or "ParamName"
    }
}

---
.\Configuration\Models\GlobalConfig.cs
---
using System.Collections.Generic;
using System.Linq;
using DynamicSqlEditor.Common;

namespace DynamicSqlEditor.Configuration.Models
{
    public class GlobalConfig
    {
        public List<string> IncludeSchemas { get; set; } = new List<string>();
        public List<string> ExcludeTables { get; set; } = new List<string>();
        public List<string> DefaultFKDisplayHeuristic { get; set; } = Constants.DefaultFKHeuristic.Split(',').ToList();
        public bool DisableCustomActionExecution { get; set; } = false;
    }
}

---
.\Configuration\Models\RelatedChildDefinition.cs
---
namespace DynamicSqlEditor.Configuration.Models
{
    public class RelatedChildDefinition
    {
        public string RelationName { get; set; }
        public string Label { get; set; }
        public string ChildTable { get; set; } // Schema.TableName
        public string ChildFKColumn { get; set; }
        public string ParentPKColumn { get; set; } // Optional, defaults to PK of current table
        public string ChildFilter { get; set; } // Optional static WHERE clause for child query
    }
}

---
.\Configuration\Models\TableConfig.cs
---
using System.Collections.Generic;
using System.Windows.Forms; // For SortOrder

namespace DynamicSqlEditor.Configuration.Models
{
    public class TableConfig
    {
        public string FullTableName { get; }
        public string CustomSelectQuery { get; set; }
        public string DefaultSortColumn { get; set; }
        public SortOrder DefaultSortDirection { get; set; } = SortOrder.Ascending;
        public string DefaultFilterName { get; set; }

        public Dictionary<string, FilterDefinition> Filters { get; } = new Dictionary<string, FilterDefinition>(System.StringComparer.OrdinalIgnoreCase);
        public Dictionary<string, DetailFormFieldDefinition> DetailFormFields { get; } = new Dictionary<string, DetailFormFieldDefinition>(System.StringComparer.OrdinalIgnoreCase);
        public Dictionary<string, FKLookupDefinition> FKLookups { get; } = new Dictionary<string, FKLookupDefinition>(System.StringComparer.OrdinalIgnoreCase);
        public Dictionary<string, ActionButtonDefinition> ActionButtons { get; } = new Dictionary<string, ActionButtonDefinition>(System.StringComparer.OrdinalIgnoreCase);
        public Dictionary<string, RelatedChildDefinition> RelatedChildren { get; } = new Dictionary<string, RelatedChildDefinition>(System.StringComparer.OrdinalIgnoreCase);

        public TableConfig(string fullTableName)
        {
            FullTableName = fullTableName;
        }
    }
}

---
.\Core\CrudManager.cs
---
// File: DynamicSqlEditor/Core/CrudManager.cs
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using DynamicSqlEditor.Common;
using DynamicSqlEditor.DataAccess;
using DynamicSqlEditor.Schema.Models;

namespace DynamicSqlEditor.Core
{
    public class CrudManager
    {
        private readonly DatabaseManager _dbManager;
        private readonly TableSchema _tableSchema;
        private readonly ConcurrencyHandler _concurrencyHandler;

        public CrudManager(DatabaseManager dbManager, TableSchema tableSchema)
        {
            _dbManager = dbManager ?? throw new ArgumentNullException(nameof(dbManager));
            _tableSchema = tableSchema ?? throw new ArgumentNullException(nameof(tableSchema));
            _concurrencyHandler = new ConcurrencyHandler(tableSchema);
        }

        public async Task<int> InsertRecordAsync(Dictionary<string, object> columnValues)
        {
            var insertColumns = _tableSchema.Columns
                .Where(c => !c.IsIdentity && !c.IsComputed && !c.IsTimestamp && columnValues.ContainsKey(c.ColumnName))
                .ToList();

            if (!insertColumns.Any())
            {
                // Check if only identity/computed/timestamp columns exist or were provided
                bool onlySpecialCols = _tableSchema.Columns.All(c => c.IsIdentity || c.IsComputed || c.IsTimestamp);
                if (onlySpecialCols)
                {
                    FileLogger.Warning($"Attempted insert into {_tableSchema.FullName} which has no insertable columns.");
                    // Depending on behavior, maybe return 0 or throw specific exception
                    return 0;
                }
                throw new InvalidOperationException("No insertable columns found or provided values for insertable columns.");
            }

            var sqlBuilder = new StringBuilder($"INSERT INTO [{_tableSchema.SchemaName}].[{_tableSchema.TableName}] (");
            sqlBuilder.Append(string.Join(", ", insertColumns.Select(c => $"[{c.ColumnName}]")));
            sqlBuilder.Append(") VALUES (");
            sqlBuilder.Append(string.Join(", ", insertColumns.Select(c => $"@{c.ColumnName}")));
            sqlBuilder.Append(");");

            // Optionally retrieve identity value if applicable
            var identityColumn = _tableSchema.Columns.FirstOrDefault(c => c.IsIdentity);
            if (identityColumn != null)
            {
                sqlBuilder.Append(" SELECT SCOPE_IDENTITY();");
            }

            var parameters = insertColumns
                .Select(c => SqlParameterHelper.CreateParameter($"@{c.ColumnName}", columnValues[c.ColumnName], c.GetSqlDbType()))
                .ToList();

            try
            {
                if (identityColumn != null)
                {
                    object result = await _dbManager.ExecuteScalarAsync(sqlBuilder.ToString(), parameters);
                    // Handle potential non-integer identity types if necessary
                    return (result == null || result == DBNull.Value) ? 0 : Convert.ToInt32(result);
                }
                else
                {
                    int rowsAffected = await _dbManager.ExecuteNonQueryAsync(sqlBuilder.ToString(), parameters);
                    return rowsAffected; // Return rows affected for non-identity inserts
                }
            }
            catch (SqlException ex)
            {
                FileLogger.Error($"Error inserting record into {_tableSchema.FullName}", ex);
                throw new DataException($"Failed to insert record: {ex.Message}", ex);
            }
        }

        public async Task<int> UpdateRecordAsync(Dictionary<string, object> columnValues, Dictionary<string, object> originalKeyValues, object originalTimestamp)
        {
            var updateColumns = _tableSchema.Columns
                .Where(c => !c.IsPrimaryKey && !c.IsIdentity && !c.IsComputed && !c.IsTimestamp && columnValues.ContainsKey(c.ColumnName))
                .ToList();

            if (!updateColumns.Any())
            {
                FileLogger.Warning($"No updatable columns provided for update on {_tableSchema.FullName}.");
                return 0; // Or throw? Depends on desired behavior.
            }
            if (_tableSchema.PrimaryKeys.Count == 0)
            {
                throw new InvalidOperationException($"Cannot update table '{_tableSchema.FullName}' as it has no primary key defined.");
            }
            if (originalKeyValues == null || !_tableSchema.PrimaryKeys.All(pk => originalKeyValues.ContainsKey(pk.Column.ColumnName)))
            {
                throw new ArgumentException("Original key values dictionary is null or missing values for one or more primary key columns.", nameof(originalKeyValues));
            }


            var sqlBuilder = new StringBuilder($"UPDATE [{_tableSchema.SchemaName}].[{_tableSchema.TableName}] SET ");
            sqlBuilder.Append(string.Join(", ", updateColumns.Select(c => $"[{c.ColumnName}] = @{c.ColumnName}")));

            var parameters = updateColumns
                .Select(c => SqlParameterHelper.CreateParameter($"@{c.ColumnName}", columnValues[c.ColumnName], c.GetSqlDbType()))
                .ToList();

            // Add WHERE clause for PKs - Access Column.ColumnName and Column.GetSqlDbType
            sqlBuilder.Append(" WHERE ");
            sqlBuilder.Append(string.Join(" AND ", _tableSchema.PrimaryKeys.Select(pk => $"[{pk.Column.ColumnName}] = @PK_{pk.Column.ColumnName}"))); // Corrected access
            parameters.AddRange(_tableSchema.PrimaryKeys.Select(pk =>
                SqlParameterHelper.CreateParameter($"@PK_{pk.Column.ColumnName}", originalKeyValues[pk.Column.ColumnName], pk.Column.GetSqlDbType()))); // Corrected access

            // Add concurrency check
            _concurrencyHandler.AddConcurrencyCheckToCommand(sqlBuilder, parameters, originalTimestamp);

            try
            {
                int rowsAffected = await _dbManager.ExecuteNonQueryAsync(sqlBuilder.ToString(), parameters);

                if (_concurrencyHandler.HasConcurrencyColumn && rowsAffected == 0)
                {
                    // Check if the record still exists with the original PK but different timestamp
                    bool exists = await CheckRecordExistsAsync(originalKeyValues);
                    if (exists)
                    {
                        throw new DBConcurrencyException($"Update failed. The record in '{_tableSchema.FullName}' may have been modified by another user.");
                    }
                    else
                    {
                        // Record doesn't exist with that PK anymore
                        throw new DBConcurrencyException($"Update failed. The record in '{_tableSchema.FullName}' may have been deleted by another user.");
                    }
                }
                if (rowsAffected == 0 && !_concurrencyHandler.HasConcurrencyColumn)
                {
                    FileLogger.Warning($"Update affected 0 rows for PKs {string.Join(",", originalKeyValues.Values)} in {_tableSchema.FullName}, but no concurrency column exists. Record might have been deleted.");
                    // Optionally throw an exception here too. Consider checking existence.
                    bool exists = await CheckRecordExistsAsync(originalKeyValues);
                    if (!exists)
                    {
                        throw new DataException($"Update failed. The record in '{_tableSchema.FullName}' no longer exists.");
                    }
                }

                return rowsAffected;
            }
            catch (SqlException ex)
            {
                FileLogger.Error($"Error updating record in {_tableSchema.FullName}", ex);
                throw new DataException($"Failed to update record: {ex.Message}", ex);
            }
        }

        public async Task<int> DeleteRecordAsync(Dictionary<string, object> keyValues, object originalTimestamp)
        {
            if (_tableSchema.PrimaryKeys.Count == 0)
            {
                throw new InvalidOperationException($"Cannot delete from table '{_tableSchema.FullName}' as it has no primary key defined.");
            }
            if (keyValues == null || !_tableSchema.PrimaryKeys.All(pk => keyValues.ContainsKey(pk.Column.ColumnName)))
            {
                throw new ArgumentException("Key values dictionary is null or missing values for one or more primary key columns.", nameof(keyValues));
            }

            var sqlBuilder = new StringBuilder($"DELETE FROM [{_tableSchema.SchemaName}].[{_tableSchema.TableName}]");
            var parameters = new List<SqlParameter>();

            // Add WHERE clause for PKs - Access Column.ColumnName and Column.GetSqlDbType
            sqlBuilder.Append(" WHERE ");
            sqlBuilder.Append(string.Join(" AND ", _tableSchema.PrimaryKeys.Select(pk => $"[{pk.Column.ColumnName}] = @PK_{pk.Column.ColumnName}"))); // Corrected access
            parameters.AddRange(_tableSchema.PrimaryKeys.Select(pk =>
                SqlParameterHelper.CreateParameter($"@PK_{pk.Column.ColumnName}", keyValues[pk.Column.ColumnName], pk.Column.GetSqlDbType()))); // Corrected access

            // Add concurrency check
            _concurrencyHandler.AddConcurrencyCheckToCommand(sqlBuilder, parameters, originalTimestamp);

            try
            {
                int rowsAffected = await _dbManager.ExecuteNonQueryAsync(sqlBuilder.ToString(), parameters);

                if (_concurrencyHandler.HasConcurrencyColumn && rowsAffected == 0)
                {
                    // Check if the record still exists with the original PK but different timestamp
                    bool exists = await CheckRecordExistsAsync(keyValues);
                    if (exists)
                    {
                        throw new DBConcurrencyException($"Delete failed. The record in '{_tableSchema.FullName}' may have been modified by another user.");
                    }
                    else
                    {
                        // Record doesn't exist with that PK anymore (already deleted?)
                        FileLogger.Warning($"Delete affected 0 rows for PKs {string.Join(",", keyValues.Values)} in {_tableSchema.FullName}. Record may have already been deleted.");
                        // Return 0 as it's effectively gone, or throw if strict concurrency needed?
                        return 0;
                    }
                }
                if (rowsAffected == 0 && !_concurrencyHandler.HasConcurrencyColumn)
                {
                    FileLogger.Warning($"Delete affected 0 rows for PKs {string.Join(",", keyValues.Values)} in {_tableSchema.FullName}, but no concurrency column exists. Record might have been deleted already.");
                    // Check existence to be sure
                    bool exists = await CheckRecordExistsAsync(keyValues);
                    if (!exists) return 0; // Already deleted, consider success
                }

                return rowsAffected;
            }
            catch (SqlException ex)
            {
                // Check for FK constraint violation on delete
                if (ex.Number == 547) // Foreign key constraint violation number
                {
                    FileLogger.Error($"Error deleting record from {_tableSchema.FullName} due to foreign key constraint.", ex);
                    throw new DataException($"Cannot delete record. It is referenced by data in other tables.", ex);
                }
                FileLogger.Error($"Error deleting record from {_tableSchema.FullName}", ex);
                throw new DataException($"Failed to delete record: {ex.Message}", ex);
            }
        }

        // Helper to check if a record exists based on PK values
        private async Task<bool> CheckRecordExistsAsync(Dictionary<string, object> keyValues)
        {
            if (_tableSchema.PrimaryKeys.Count == 0 || keyValues == null || !_tableSchema.PrimaryKeys.All(pk => keyValues.ContainsKey(pk.Column.ColumnName)))
            {
                return false; // Cannot check if PK info is missing
            }

            var sqlBuilder = new StringBuilder($"SELECT COUNT(*) FROM {_tableSchema.FullName} WHERE ");
            sqlBuilder.Append(string.Join(" AND ", _tableSchema.PrimaryKeys.Select(pk => $"[{pk.Column.ColumnName}] = @PK_{pk.Column.ColumnName}")));

            var parameters = _tableSchema.PrimaryKeys.Select(pk =>
                SqlParameterHelper.CreateParameter($"@PK_{pk.Column.ColumnName}", keyValues[pk.Column.ColumnName], pk.Column.GetSqlDbType())).ToList();

            try
            {
                object result = await _dbManager.ExecuteScalarAsync(sqlBuilder.ToString(), parameters);
                return Convert.ToInt32(result ?? 0) > 0;
            }
            catch (Exception ex)
            {
                FileLogger.Error($"Error checking record existence in {_tableSchema.FullName}", ex);
                return false; // Assume not found on error? Or rethrow?
            }
        }
    }
}

---
.\Core\DataViewManager.cs
---
// File: DynamicSqlEditor/Core/DataViewManager.cs
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient; // Includes System.Data.SqlClient.SortOrder
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms; // Includes System.Windows.Forms.SortOrder
using DynamicSqlEditor.Common;
using DynamicSqlEditor.Configuration.Models;
using DynamicSqlEditor.DataAccess;
using DynamicSqlEditor.Schema.Models;

namespace DynamicSqlEditor.Core
{
    public class DataViewManager
    {
        private readonly DatabaseManager _dbManager;
        private readonly TableSchema _tableSchema;
        private readonly TableConfig _tableConfig;
        private readonly QueryBuilder _queryBuilder;
        private readonly DataPager _dataPager;

        public int CurrentPage { get; private set; } = 1;
        public int PageSize { get; set; } = 50; // Default page size
        public int TotalRecords { get; private set; } = 0;
        public int TotalPages => (TotalRecords == 0 || PageSize <= 0) ? 1 : (int)Math.Ceiling((double)TotalRecords / PageSize); // Avoid division by zero, ensure at least 1 page if 0 records

        public string CurrentSortColumn { get; private set; }
        // Explicitly qualify the type here
        public System.Windows.Forms.SortOrder CurrentSortDirection { get; private set; } = System.Windows.Forms.SortOrder.Ascending;

        public FilterDefinition CurrentFilter { get; private set; }
        public Dictionary<string, object> CurrentFilterParameters { get; private set; } = new Dictionary<string, object>();

        // Add DbManager property if needed by others (like FilterInputDialog lookup helpers)
        public DatabaseManager DbManager => _dbManager;


        public DataViewManager(DatabaseManager dbManager, TableSchema tableSchema, TableConfig tableConfig)
        {
            _dbManager = dbManager ?? throw new ArgumentNullException(nameof(dbManager));
            _tableSchema = tableSchema ?? throw new ArgumentNullException(nameof(tableSchema));
            _tableConfig = tableConfig ?? throw new ArgumentNullException(nameof(tableConfig));

            _queryBuilder = new QueryBuilder(_tableSchema, _tableConfig);
            _dataPager = new DataPager(_dbManager);

            ApplyDefaultSort();
            ApplyDefaultFilter();
        }

        private void ApplyDefaultSort()
        {
            CurrentSortColumn = _tableConfig.DefaultSortColumn;
            // The type of _tableConfig.DefaultSortDirection is already System.Windows.Forms.SortOrder
            // The type of CurrentSortDirection is now explicitly System.Windows.Forms.SortOrder
            // So this assignment should now be valid without explicit cast/qualification here.
            CurrentSortDirection = _tableConfig.DefaultSortDirection; // Line 49

            if (string.IsNullOrEmpty(CurrentSortColumn) && _tableSchema.PrimaryKeys.Any())
            {
                CurrentSortColumn = _tableSchema.PrimaryKeys.First().Column.ColumnName;
                CurrentSortDirection = System.Windows.Forms.SortOrder.Ascending; // Qualify here too for clarity
            }
            // Add fallback if no PK and no default sort?
            else if (string.IsNullOrEmpty(CurrentSortColumn))
            {
                var firstCol = _tableSchema.Columns.OrderBy(c => c.OrdinalPosition).FirstOrDefault();
                if (firstCol != null)
                {
                    CurrentSortColumn = firstCol.ColumnName;
                    CurrentSortDirection = System.Windows.Forms.SortOrder.Ascending;
                    FileLogger.Warning($"No primary key or default sort column specified for {_tableSchema.FullName}. Defaulting to first column '{CurrentSortColumn}'.");
                }
                else
                {
                    FileLogger.Error($"Cannot determine default sort for {_tableSchema.FullName}. No PK, no default, and no columns found.");
                    // Leave CurrentSortColumn null, QueryBuilder might handle it
                }
            }
        }

        private void ApplyDefaultFilter()
        {
            if (!string.IsNullOrEmpty(_tableConfig.DefaultFilterName) &&
                _tableConfig.Filters.TryGetValue(_tableConfig.DefaultFilterName, out var defaultFilter))
            {
                if (string.IsNullOrEmpty(defaultFilter.RequiresInput)) // Only apply if no input needed initially
                {
                    CurrentFilter = defaultFilter;
                }
                else
                {
                    FileLogger.Info($"Default filter '{_tableConfig.DefaultFilterName}' requires input and will not be applied automatically on load.");
                }
            }
        }

        public async Task<(DataTable Data, int TotalRecords)> LoadDataAsync(int pageNumber)
        {
            if (pageNumber < 1) pageNumber = 1;
            // Don't clamp pageNumber to TotalPages here, let DataPager handle it after count

            string baseQuery = _queryBuilder.GetSelectQuery();
            // Pass the explicitly typed CurrentSortDirection
            string orderByClause = _queryBuilder.GetOrderByClause(CurrentSortColumn, this.CurrentSortDirection);
            string whereClause = _queryBuilder.GetWhereClause(CurrentFilter);

            var parameters = _queryBuilder.GetFilterParameters(CurrentFilter, CurrentFilterParameters);

            try
            {
                // Let DataPager calculate total and adjust page if needed
                var (data, total) = await _dataPager.GetPagedDataAsync(baseQuery, whereClause, orderByClause, parameters, pageNumber, PageSize);
                TotalRecords = total;

                // Now determine the correct CurrentPage based on results
                int actualTotalPages = this.TotalPages; // Use calculated property
                if (pageNumber > actualTotalPages && actualTotalPages > 0)
                {
                    CurrentPage = actualTotalPages;
                    // Reload data for the *actual* last page if the requested page was too high
                    FileLogger.Info($"Requested page {pageNumber} exceeds total pages {actualTotalPages}. Loading page {CurrentPage} instead.");
                    (data, total) = await _dataPager.GetPagedDataAsync(baseQuery, whereClause, orderByClause, parameters, CurrentPage, PageSize);
                    // TotalRecords should be the same, but update just in case
                    TotalRecords = total;
                }
                else if (actualTotalPages == 0) // Handle case where filter results in 0 records
                {
                    CurrentPage = 1;
                }
                else
                {
                    CurrentPage = pageNumber; // Requested page was valid
                }

                return (data, total);
            }
            catch (Exception ex)
            {
                FileLogger.Error($"Error loading data for table {_tableSchema.FullName}", ex);
                TotalRecords = 0; // Reset count on error
                CurrentPage = 1;
                throw; // Re-throw to be handled by UI
            }
        }

        public async Task<(DataTable Data, int TotalRecords)> RefreshDataAsync()
        {
            // Reload data for the current page, sort, and filter
            return await LoadDataAsync(CurrentPage);
        }

        public async Task<(DataTable Data, int TotalRecords)> GoToPageAsync(int pageNumber)
        {
            // Basic validation, LoadDataAsync will handle clamping if needed after count
            if (pageNumber < 1) pageNumber = 1;
            return await LoadDataAsync(pageNumber);
        }

        public async Task<(DataTable Data, int TotalRecords)> NextPageAsync()
        {
            // Allow going past end, LoadDataAsync will clamp
            return await GoToPageAsync(CurrentPage + 1);
        }

        public async Task<(DataTable Data, int TotalRecords)> PreviousPageAsync()
        {
            return await GoToPageAsync(CurrentPage - 1); // Clamped to 1 by GoToPageAsync/LoadDataAsync
        }

        public async Task<(DataTable Data, int TotalRecords)> FirstPageAsync()
        {
            return await GoToPageAsync(1);
        }

        public async Task<(DataTable Data, int TotalRecords)> LastPageAsync()
        {
            // Calculate TotalPages based on current TotalRecords before navigating
            int lastPage = this.TotalPages;
            return await GoToPageAsync(lastPage > 0 ? lastPage : 1);
        }

        public async Task<(DataTable Data, int TotalRecords)> ApplySortAsync(string columnName)
        {
            if (string.IsNullOrEmpty(columnName))
            {
                // Maybe reset to default sort? Or clear sort?
                // Let's reset to default defined in config or by PK
                ApplyDefaultSort();
                return await LoadDataAsync(1);
            }

            if (CurrentSortColumn == columnName)
            {
                // Toggle direction, explicitly qualify
                CurrentSortDirection = (CurrentSortDirection == System.Windows.Forms.SortOrder.Ascending) ? System.Windows.Forms.SortOrder.Descending : System.Windows.Forms.SortOrder.Ascending;
            }
            else
            {
                CurrentSortColumn = columnName;
                CurrentSortDirection = System.Windows.Forms.SortOrder.Ascending; // Default to Ascending on new column
            }
            return await LoadDataAsync(1); // Reset to first page on sort change
        }

        public async Task<(DataTable Data, int TotalRecords)> ApplyFilterAsync(FilterDefinition filter, Dictionary<string, object> parameters)
        {
            CurrentFilter = filter;
            CurrentFilterParameters = parameters ?? new Dictionary<string, object>();
            return await LoadDataAsync(1); // Reset to first page on filter change
        }

        public async Task<(DataTable Data, int TotalRecords)> ClearFilterAsync()
        {
            CurrentFilter = null;
            CurrentFilterParameters.Clear();
            return await LoadDataAsync(1); // Reset to first page
        }

        public async Task<DataTable> GetLookupDataAsync(FKLookupDefinition lookupConfig)
        {
            if (lookupConfig == null) throw new ArgumentNullException(nameof(lookupConfig));

            string valueCol = lookupConfig.ValueColumn ?? await GetPrimaryKeyColumnAsync(lookupConfig.ReferencedTable);
            if (string.IsNullOrEmpty(valueCol))
            {
                throw new InvalidOperationException($"Cannot determine ValueColumn for lookup on table {lookupConfig.ReferencedTable}. Specify ValueColumn in config or ensure table has a single PK.");
            }

            // Ensure columns are quoted correctly, especially if coming from config/heuristics
            string displayColQuoted = $"[{lookupConfig.DisplayColumn.Trim('[', ']')}]";
            string valueColQuoted = $"[{valueCol.Trim('[', ']')}]";

            // Use PARSENAME for robust table name splitting and quoting
            string safeReferencedTable = $"[{PARSENAME(lookupConfig.ReferencedTable, 2)}].[{PARSENAME(lookupConfig.ReferencedTable, 1)}]";


            string sql = $"SELECT DISTINCT {displayColQuoted}, {valueColQuoted} FROM {safeReferencedTable} ORDER BY {displayColQuoted}";

            try
            {
                return await _dbManager.ExecuteQueryAsync(sql, null);
            }
            catch (Exception ex)
            {
                FileLogger.Error($"Error fetching lookup data for {lookupConfig.ReferencedTable}", ex);
                throw;
            }
        }

        public async Task<DataTable> GetRelatedDataAsync(RelatedChildDefinition relatedConfig, Dictionary<string, object> parentKeyValues)
        {
            if (relatedConfig == null) throw new ArgumentNullException(nameof(relatedConfig));
            if (parentKeyValues == null || !parentKeyValues.Any()) return new DataTable(); // No parent selected

            string parentPkColumn = relatedConfig.ParentPKColumn;
            if (string.IsNullOrEmpty(parentPkColumn))
            {
                if (_tableSchema.PrimaryKeys.Count == 1)
                {
                    parentPkColumn = _tableSchema.PrimaryKeys.First().Column.ColumnName;
                }
                else
                {
                    throw new InvalidOperationException($"Cannot determine ParentPKColumn for relation '{relatedConfig.RelationName}'. Specify ParentPKColumn in config or ensure parent table '{_tableSchema.FullName}' has a single PK.");
                }
            }

            if (!parentKeyValues.ContainsKey(parentPkColumn))
            {
                FileLogger.Error($"Parent key dictionary does not contain the required key '{parentPkColumn}' for relation '{relatedConfig.RelationName}'.");
                return new DataTable();
            }

            // Use PARSENAME for robust table name splitting and quoting
            string safeChildTable = $"[{PARSENAME(relatedConfig.ChildTable, 2)}].[{PARSENAME(relatedConfig.ChildTable, 1)}]";
            string childFkColQuoted = $"[{relatedConfig.ChildFKColumn.Trim('[', ']')}]";


            var sqlBuilder = new StringBuilder($"SELECT * FROM {safeChildTable}");
            sqlBuilder.Append($" WHERE {childFkColQuoted} = @ParentKeyValue");

            // Get SqlDbType for the parameter if possible
            var parentPkColSchema = _tableSchema.GetColumn(parentPkColumn);
            var parameters = new List<SqlParameter>
             {
                 SqlParameterHelper.CreateParameter("@ParentKeyValue", parentKeyValues[parentPkColumn], parentPkColSchema?.GetSqlDbType())
             };

            if (!string.IsNullOrWhiteSpace(relatedConfig.ChildFilter))
            {
                // WARNING: Potential for SQL injection if ChildFilter contains dynamic parts not parameterized.
                // Assume ChildFilter is static for now. For dynamic values, parameterization is needed.
                // Basic validation: Check for comments, common injection patterns? Risky.
                if (relatedConfig.ChildFilter.Contains("--") || relatedConfig.ChildFilter.Contains(";") || relatedConfig.ChildFilter.Contains("/*"))
                {
                    FileLogger.Error($"Potential SQL injection detected in RelatedChild.ChildFilter for relation '{relatedConfig.RelationName}'. Aborting query.");
                    throw new InvalidOperationException("Invalid characters detected in ChildFilter configuration.");
                }
                sqlBuilder.Append($" AND ({relatedConfig.ChildFilter})");
            }

            sqlBuilder.Append($" ORDER BY {childFkColQuoted}"); // Default sort, could be configurable

            try
            {
                return await _dbManager.ExecuteQueryAsync(sqlBuilder.ToString(), parameters);
            }
            catch (Exception ex)
            {
                FileLogger.Error($"Error fetching related data for relation '{relatedConfig.RelationName}'", ex);
                throw;
            }
        }


        private async Task<string> GetPrimaryKeyColumnAsync(string fullTableName)
        {
            // This might require a separate schema lookup if not already cached
            // For simplicity, assume single PK for now or require explicit ValueColumn
            // A real implementation would query INFORMATION_SCHEMA.KEY_COLUMN_USAGE
            try
            {
                // Use PARSENAME for safety
                string safeSchema = PARSENAME(fullTableName, 2);
                string safeTable = PARSENAME(fullTableName, 1);

                if (safeSchema == null || safeTable == null)
                {
                    FileLogger.Error($"Invalid table name format for PK lookup: {fullTableName}");
                    return null;
                }

                string query = @"
                    SELECT TOP 1 COLUMN_NAME
                    FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE
                    WHERE OBJECTPROPERTY(OBJECT_ID(CONSTRAINT_SCHEMA + '.' + QUOTENAME(CONSTRAINT_NAME)), 'IsPrimaryKey') = 1
                    AND TABLE_SCHEMA = @Schema AND TABLE_NAME = @Table;";
                var parameters = new List<SqlParameter> {
                     SqlParameterHelper.CreateParameter("@Schema", safeSchema),
                     SqlParameterHelper.CreateParameter("@Table", safeTable)
                 };
                object result = await _dbManager.ExecuteScalarAsync(query, parameters);
                return result?.ToString();
            }
            catch (Exception ex)
            {
                FileLogger.Error($"Failed to get primary key for table {fullTableName}", ex);
                return null;
            }
        }

        // Helper for safe table/schema name parsing
        private string PARSENAME(string objectName, int part)
        {
            // Basic simulation if PARSENAME isn't available or for non-SQL source
            // Assumes "Schema.Table" or just "Table" format
            var parts = objectName.Split('.');
            if (part == 1) // Table Name
            {
                return parts.Length > 1 ? parts[1].Trim('[', ']') : parts[0].Trim('[', ']');
            }
            if (part == 2) // Schema Name
            {
                return parts.Length > 1 ? parts[0].Trim('[', ']') : "dbo"; // Default schema if not specified
            }
            return null; // Invalid part
        }
    }
}

---
.\Core\StateManager.cs
---
using System;
using System.Collections.Generic;
using System.Linq; // Ensure Linq is included
using DynamicSqlEditor.Configuration;
using DynamicSqlEditor.DataAccess;
using DynamicSqlEditor.Schema; // <-- Make sure this line exists
using DynamicSqlEditor.Schema.Models;
using DynamicSqlEditor.Common; // For FileLogger

namespace DynamicSqlEditor.Core
{
    public class StateManager
    {
        public ConfigurationManager ConfigManager { get; }
        public DatabaseManager DbManager { get; private set; }
        public SchemaProvider SchemaProvider { get; private set; }
        public List<TableSchema> AvailableTables { get; private set; } = new List<TableSchema>();
        public bool IsConnected => DbManager?.IsConnected() ?? false;
        public string CurrentDatabaseName { get; private set; }

        public event EventHandler ConnectionChanged;
        public event EventHandler SchemaRefreshed;

        public StateManager()
        {
            ConfigManager = new ConfigurationManager();
        }

        public bool Initialize()
        {
            bool configLoaded = ConfigManager.LoadConfiguration(); // Load global config first

            if (ConfigManager.CurrentConfig?.Connection?.ConnectionString != null)
            {
                if (ConnectToDatabase())
                {
                    RefreshSchema();
                    return true;
                }
                else
                {
                    // Connection failed based on initial config
                    return false;
                }
            }
            else
            {
                FileLogger.Warning("No connection string found in configuration. Cannot connect automatically.");
                return false; // Cannot proceed without connection
            }
        }

        public bool ConnectToDatabase(string connectionString = null, int? queryTimeout = null)
        {
            string connStr = connectionString ?? ConfigManager.CurrentConfig?.Connection?.ConnectionString;
            int timeout = queryTimeout ?? ConfigManager.CurrentConfig?.Connection?.QueryTimeout ?? Constants.DefaultQueryTimeout;

            if (string.IsNullOrEmpty(connStr))
            {
                FileLogger.Error("Attempted to connect with an empty connection string.");
                return false;
            }

            try
            {
                DbManager?.Dispose(); // Dispose previous connection if any
                DbManager = new DatabaseManager(connStr, timeout);
                DbManager.TestConnection(); // Verify connection works

                CurrentDatabaseName = DbManager.GetDatabaseName();
                FileLogger.Info($"Successfully connected to database: {CurrentDatabaseName}");

                // Reload config potentially merging DB specific file
                ConfigManager.LoadConfiguration(CurrentDatabaseName);

                // Update DbManager timeout if config changed
                DbManager.DefaultTimeout = ConfigManager.CurrentConfig.Connection.QueryTimeout;

                SchemaProvider = new SchemaProvider(DbManager);
                OnConnectionChanged();
                return true;
            }
            catch (Exception ex)
            {
                FileLogger.Error($"Database connection failed for string: {connStr}", ex);
                DbManager = null;
                SchemaProvider = null;
                CurrentDatabaseName = null;
                OnConnectionChanged();
                return false;
            }
        }

        public void Disconnect()
        {
            DbManager?.Dispose();
            DbManager = null;
            SchemaProvider = null;
            AvailableTables.Clear();
            CurrentDatabaseName = null;
            FileLogger.Info("Disconnected from database.");
            OnConnectionChanged();
            OnSchemaRefreshed();
        }

        public void RefreshSchema()
        {
            if (!IsConnected || SchemaProvider == null)
            {
                AvailableTables.Clear();
                OnSchemaRefreshed();
                return;
            }

            try
            {
                FileLogger.Info("Refreshing database schema...");
                var allTables = SchemaProvider.GetAllTables();
                // Line 118 should now work
                AvailableTables = SchemaFilter.FilterTables(allTables, ConfigManager.CurrentConfig.Global);
                FileLogger.Info($"Schema refreshed. Found {AvailableTables.Count} available tables after filtering.");
                OnSchemaRefreshed();
            }
            catch (Exception ex)
            {
                FileLogger.Error("Failed to refresh database schema.", ex);
                AvailableTables.Clear();
                OnSchemaRefreshed();
                // Maybe show an error to the user?
            }
        }

        protected virtual void OnConnectionChanged()
        {
            ConnectionChanged?.Invoke(this, EventArgs.Empty);
        }

        protected virtual void OnSchemaRefreshed()
        {
            SchemaRefreshed?.Invoke(this, EventArgs.Empty);
        }
    }
}

---
.\DataAccess\ConcurrencyHandler.cs
---
// File: DynamicSqlEditor/DataAccess/ConcurrencyHandler.cs
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Linq;
using System.Text;
using DynamicSqlEditor.Common;
using DynamicSqlEditor.Schema.Models;

namespace DynamicSqlEditor.DataAccess
{
    public class ConcurrencyHandler
    {
        private readonly ColumnSchema _timestampColumn;

        public bool HasConcurrencyColumn => _timestampColumn != null;

        public ConcurrencyHandler(TableSchema tableSchema)
        {
            _timestampColumn = tableSchema?.Columns.FirstOrDefault(c => c.IsTimestamp);
        }

        public void AddConcurrencyCheckToCommand(StringBuilder sqlBuilder, List<SqlParameter> parameters, object originalTimestampValue)
        {
            if (!HasConcurrencyColumn) return;

            if (originalTimestampValue == null || originalTimestampValue == DBNull.Value)
            {
                // This case is tricky. If the original timestamp was null (e.g., newly inserted row not refreshed?),
                // we cannot perform a reliable concurrency check based on timestamp.
                // Options:
                // 1. Throw an exception: Safest, forces refresh before edit/delete.
                // 2. Skip timestamp check: Riskier, might overwrite changes.
                // 3. Check if timestamp IS NULL: Only works if it's possible for it to be null (unlikely for rowversion).
                FileLogger.Warning($"Concurrency check skipped for table '{_timestampColumn.ParentTable.FullName}' because original timestamp value was null.");
                // For now, we skip the check if the original value is null. Consider throwing instead.
                return;
                // throw new InvalidOperationException("Cannot perform concurrency check: Original timestamp value is missing.");
            }

            // Ensure WHERE clause exists before adding AND
            string sql = sqlBuilder.ToString();
            // Use IndexOf with StringComparison instead of Contains with two arguments
            if (sql.IndexOf(" WHERE ", StringComparison.OrdinalIgnoreCase) == -1) // Corrected check
            {
                // This should not happen if called after PK checks are added
                FileLogger.Error("Concurrency check attempted before WHERE clause was added.");
                throw new InvalidOperationException("WHERE clause missing before adding concurrency check.");
            }

            // Append the timestamp check condition
            sqlBuilder.Append($" AND [{_timestampColumn.ColumnName}] = @Original_{_timestampColumn.ColumnName}");

            // Add the timestamp parameter
            parameters.Add(SqlParameterHelper.CreateParameter($"@Original_{_timestampColumn.ColumnName}", originalTimestampValue, _timestampColumn.GetSqlDbType()));
        }

        public object GetTimestampValue(DataRowView rowView)
        {
            if (!HasConcurrencyColumn || rowView == null || !rowView.Row.Table.Columns.Contains(_timestampColumn.ColumnName))
            {
                return null;
            }
            return rowView[_timestampColumn.ColumnName];
        }

        public object GetTimestampValue(Dictionary<string, object> data)
        {
            if (!HasConcurrencyColumn || data == null || !data.ContainsKey(_timestampColumn.ColumnName))
            {
                return null;
            }
            return data[_timestampColumn.ColumnName];
        }
    }
}

---
.\DataAccess\DataPager.cs
---
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using DynamicSqlEditor.Common;

namespace DynamicSqlEditor.DataAccess
{
    public class DataPager
    {
        private readonly DatabaseManager _dbManager;
        private bool? _supportsOffsetFetch = null;

        public DataPager(DatabaseManager dbManager)
        {
            _dbManager = dbManager ?? throw new ArgumentNullException(nameof(dbManager));
        }

        private async Task<bool> CheckOffsetFetchSupportAsync()
        {
            if (_supportsOffsetFetch.HasValue) return _supportsOffsetFetch.Value;

            try
            {
                // Simple query using OFFSET FETCH to check syntax support
                string testQuery = "SELECT 1 ORDER BY (SELECT NULL) OFFSET 0 ROWS FETCH NEXT 0 ROWS ONLY;";
                await _dbManager.ExecuteScalarAsync(testQuery, null);
                _supportsOffsetFetch = true;
                FileLogger.Info("Database supports OFFSET/FETCH paging.");
            }
            catch (SqlException ex) when (ex.Number == 102 || ex.Number == 156) // Incorrect syntax errors
            {
                _supportsOffsetFetch = false;
                FileLogger.Info("Database does not support OFFSET/FETCH paging. Falling back to ROW_NUMBER().");
            }
            catch (Exception ex)
            {
                 FileLogger.Error("Error checking OFFSET/FETCH support. Assuming not supported.", ex);
                _supportsOffsetFetch = false; // Assume not supported on other errors
            }
            return _supportsOffsetFetch.Value;
        }

        public async Task<(DataTable Data, int TotalRecords)> GetPagedDataAsync(
            string baseSelectQuery,
            string whereClause,
            string orderByClause,
            List<SqlParameter> parameters,
            int pageNumber,
            int pageSize)
        {
            if (pageNumber < 1) pageNumber = 1;
            if (pageSize < 1) pageSize = 1; // Avoid division by zero or invalid fetch

            parameters = parameters ?? new List<SqlParameter>();

            // --- 1. Get Total Record Count ---
            string countQuery = BuildCountQuery(baseSelectQuery, whereClause);
            object totalRecordsObj = await _dbManager.ExecuteScalarAsync(countQuery, parameters);
            int totalRecords = Convert.ToInt32(totalRecordsObj ?? 0);

            if (totalRecords == 0)
            {
                return (new DataTable(), 0); // No records, return empty table
            }

            // --- 2. Get Paged Data ---
            string pagedQuery;
            bool useOffsetFetch = await CheckOffsetFetchSupportAsync();

            if (useOffsetFetch)
            {
                pagedQuery = BuildOffsetFetchQuery(baseSelectQuery, whereClause, orderByClause, pageNumber, pageSize);
            }
            else
            {
                pagedQuery = BuildRowNumberQuery(baseSelectQuery, whereClause, orderByClause, pageNumber, pageSize);
            }

            // Add paging parameters (might be reused if names are consistent)
            if (!parameters.Any(p => p.ParameterName == "@PageSize"))
                parameters.Add(SqlParameterHelper.CreateParameter("@PageSize", pageSize));
            if (!parameters.Any(p => p.ParameterName == "@Offset"))
                parameters.Add(SqlParameterHelper.CreateParameter("@Offset", (pageNumber - 1) * pageSize));
             if (!useOffsetFetch) // ROW_NUMBER needs start/end row numbers
             {
                 if (!parameters.Any(p => p.ParameterName == "@StartRow"))
                    parameters.Add(SqlParameterHelper.CreateParameter("@StartRow", (pageNumber - 1) * pageSize + 1));
                 if (!parameters.Any(p => p.ParameterName == "@EndRow"))
                    parameters.Add(SqlParameterHelper.CreateParameter("@EndRow", pageNumber * pageSize));
             }


            DataTable data = await _dbManager.ExecuteQueryAsync(pagedQuery, parameters);

            return (data, totalRecords);
        }

        private string BuildCountQuery(string baseSelectQuery, string whereClause)
        {
             // Basic approach: Replace SELECT list with COUNT(*)
             // More robust parsing might be needed for complex SELECTs (e.g., with subqueries in select list)
             int fromIndex = baseSelectQuery.IndexOf(" FROM ", StringComparison.OrdinalIgnoreCase);
             if (fromIndex == -1) throw new ArgumentException("Invalid baseSelectQuery: 'FROM' clause not found.");

             string fromAndWhere = baseSelectQuery.Substring(fromIndex);
             if (!string.IsNullOrWhiteSpace(whereClause))
             {
                 // Check if base query already has WHERE
                 int existingWhereIndex = fromAndWhere.IndexOf(Constants.WherePlaceholder, StringComparison.OrdinalIgnoreCase);
                 if (existingWhereIndex != -1)
                 {
                     fromAndWhere = fromAndWhere.Replace(Constants.WherePlaceholder, $"WHERE {whereClause}");
                 }
                 else // Append if no placeholder
                 {
                      // Need to check if the base query *itself* might contain a WHERE clause already
                      // This simple replacement assumes {WHERE} is the only place it goes.
                      // A safer approach might involve more complex SQL parsing or requiring {WHERE}
                      if (!fromAndWhere.TrimEnd().EndsWith("WHERE", StringComparison.OrdinalIgnoreCase)) // Avoid double WHERE
                      {
                           fromAndWhere += $" WHERE {whereClause}";
                      }
                      else
                      {
                           fromAndWhere += $" {whereClause}"; // Append condition if base ends with WHERE
                      }
                 }
             }
             else
             {
                 // Remove placeholder if no filter applied
                 fromAndWhere = fromAndWhere.Replace(Constants.WherePlaceholder, "");
             }

             // Remove ORDER BY and PAGING placeholders if they exist in the count context
             fromAndWhere = fromAndWhere.Replace(Constants.OrderByPlaceholder, "");
             fromAndWhere = fromAndWhere.Replace(Constants.PagingPlaceholder, "");


             return $"SELECT COUNT(*) {fromAndWhere}";
        }

        private string BuildOffsetFetchQuery(string baseSelectQuery, string whereClause, string orderByClause, int pageNumber, int pageSize)
        {
            if (string.IsNullOrWhiteSpace(orderByClause))
            {
                throw new InvalidOperationException("ORDER BY clause is required for OFFSET/FETCH paging.");
            }

            string pagingClause = $"OFFSET @Offset ROWS FETCH NEXT @PageSize ROWS ONLY";

            string query = baseSelectQuery;

            if (!string.IsNullOrWhiteSpace(whereClause))
            {
                 query = query.Replace(Constants.WherePlaceholder, $"WHERE {whereClause}");
            }
            else
            {
                 query = query.Replace(Constants.WherePlaceholder, ""); // Remove placeholder
            }

            query = query.Replace(Constants.OrderByPlaceholder, $"ORDER BY {orderByClause}");
            query = query.Replace(Constants.PagingPlaceholder, pagingClause);

            // Ensure placeholders were present and replaced
            if (!query.Contains(pagingClause)) query += " " + pagingClause; // Append if placeholder missing
            if (!query.Contains($"ORDER BY {orderByClause}")) query += $" ORDER BY {orderByClause} {pagingClause}"; // Append order by + paging if missing


            return query;
        }

        private string BuildRowNumberQuery(string baseSelectQuery, string whereClause, string orderByClause, int pageNumber, int pageSize)
        {
            if (string.IsNullOrWhiteSpace(orderByClause))
            {
                throw new InvalidOperationException("ORDER BY clause is required for ROW_NUMBER() paging.");
            }

            // Remove placeholders from the inner query first
            string innerQuery = baseSelectQuery;
             if (!string.IsNullOrWhiteSpace(whereClause))
            {
                 innerQuery = innerQuery.Replace(Constants.WherePlaceholder, $"WHERE {whereClause}");
            }
            else
            {
                 innerQuery = innerQuery.Replace(Constants.WherePlaceholder, ""); // Remove placeholder
            }
            // Remove ORDER BY and PAGING from inner as they are handled by ROW_NUMBER()
            innerQuery = innerQuery.Replace(Constants.OrderByPlaceholder, "");
            innerQuery = innerQuery.Replace(Constants.PagingPlaceholder, "");


            // Find the SELECT list end and FROM start
            int selectEndIndex = innerQuery.IndexOf("SELECT ", StringComparison.OrdinalIgnoreCase) + "SELECT ".Length;
            int fromIndex = innerQuery.IndexOf(" FROM ", StringComparison.OrdinalIgnoreCase);
            if (fromIndex == -1) throw new ArgumentException("Invalid baseSelectQuery: 'FROM' clause not found.");

            string selectList = innerQuery.Substring(selectEndIndex, fromIndex - selectEndIndex).Trim();
            string fromClause = innerQuery.Substring(fromIndex);

            // Construct the ROW_NUMBER query
            var sb = new StringBuilder();
            sb.AppendLine("WITH PagedData AS (");
            sb.Append("  SELECT ");
            // Handle SELECT * - needs expansion or alias
            if (selectList.Trim() == "*")
            {
                 sb.Append("InnerQuery.*"); // Assuming no column name conflicts
            }
            else
            {
                 sb.Append(selectList);
            }
            sb.AppendLine(",");
            sb.AppendLine($"    ROW_NUMBER() OVER (ORDER BY {orderByClause}) AS RowNum");
            // Use a subquery alias to handle potential SELECT *
            sb.AppendLine($"  FROM ({innerQuery}) AS InnerQuery");
            sb.AppendLine(")");
            sb.AppendLine("SELECT *"); // Select all columns including RowNum initially, or list explicitly
            // Could refine to exclude RowNum: SELECT col1, col2... FROM PagedData WHERE RowNum BETWEEN...
            sb.AppendLine("FROM PagedData");
            sb.AppendLine("WHERE RowNum BETWEEN @StartRow AND @EndRow");
            sb.AppendLine($"ORDER BY RowNum;"); // Order by RowNum to maintain sequence

            return sb.ToString();
        }
    }
}

---
.\DataAccess\DatabaseManager.cs
---
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Threading.Tasks;
using DynamicSqlEditor.Common;

namespace DynamicSqlEditor.DataAccess
{
    public class DatabaseManager : IDisposable
    {
        private readonly string _connectionString;
        public int DefaultTimeout { get; set; }

        public DatabaseManager(string connectionString, int defaultTimeout)
        {
            if (string.IsNullOrWhiteSpace(connectionString))
                throw new ArgumentNullException(nameof(connectionString));

            _connectionString = connectionString;
            DefaultTimeout = defaultTimeout;
        }

        public SqlConnection CreateConnection()
        {
            return new SqlConnection(_connectionString);
        }

        public void TestConnection()
        {
            try
            {
                using (var connection = CreateConnection())
                {
                    connection.Open();
                    FileLogger.Info($"Connection test successful to: {connection.DataSource}/{connection.Database}");
                }
            }
            catch (Exception ex)
            {
                FileLogger.Error($"Connection test failed: {ex.Message}");
                throw; // Re-throw to indicate failure
            }
        }

         public bool IsConnected()
        {
            try
            {
                using (var connection = CreateConnection())
                {
                    connection.Open();
                    return true;
                }
            }
            catch
            {
                return false;
            }
        }

        public string GetDatabaseName()
        {
             try
            {
                using (var connection = CreateConnection())
                {
                    return connection.Database;
                }
            }
            catch (Exception ex)
            {
                FileLogger.Error($"Failed to get database name from connection string.", ex);
                return null;
            }
        }


        public async Task<DataTable> ExecuteQueryAsync(string sql, List<SqlParameter> parameters)
        {
            var dataTable = new DataTable();
            try
            {
                using (var connection = CreateConnection())
                using (var command = new SqlCommand(sql, connection))
                {
                    command.CommandTimeout = DefaultTimeout;
                    if (parameters != null)
                    {
                        command.Parameters.AddRange(parameters.ToArray());
                    }

                    await connection.OpenAsync();
                    using (var reader = await command.ExecuteReaderAsync())
                    {
                        dataTable.Load(reader);
                    }
                }
            }
            catch (SqlException ex)
            {
                FileLogger.Error($"SQL Error executing query: {sql}", ex);
                throw; // Re-throw SqlException
            }
            catch (Exception ex)
            {
                FileLogger.Error($"General Error executing query: {sql}", ex);
                throw; // Re-throw other exceptions
            }
            return dataTable;
        }

        public async Task<int> ExecuteNonQueryAsync(string sql, List<SqlParameter> parameters)
        {
            try
            {
                using (var connection = CreateConnection())
                using (var command = new SqlCommand(sql, connection))
                {
                    command.CommandTimeout = DefaultTimeout;
                    if (parameters != null)
                    {
                        command.Parameters.AddRange(parameters.ToArray());
                    }

                    await connection.OpenAsync();
                    return await command.ExecuteNonQueryAsync();
                }
            }
            catch (SqlException ex)
            {
                FileLogger.Error($"SQL Error executing non-query: {sql}", ex);
                throw;
            }
             catch (Exception ex)
            {
                FileLogger.Error($"General Error executing non-query: {sql}", ex);
                throw;
            }
        }

        public async Task<object> ExecuteScalarAsync(string sql, List<SqlParameter> parameters)
        {
            try
            {
                using (var connection = CreateConnection())
                using (var command = new SqlCommand(sql, connection))
                {
                    command.CommandTimeout = DefaultTimeout;
                    if (parameters != null)
                    {
                        command.Parameters.AddRange(parameters.ToArray());
                    }

                    await connection.OpenAsync();
                    return await command.ExecuteScalarAsync();
                }
            }
            catch (SqlException ex)
            {
                FileLogger.Error($"SQL Error executing scalar: {sql}", ex);
                throw;
            }
             catch (Exception ex)
            {
                FileLogger.Error($"General Error executing scalar: {sql}", ex);
                throw;
            }
        }

        public void Dispose()
        {
            // SqlConnection handles pooling, so explicit disposal of the manager isn't strictly necessary
            // unless holding other resources.
        }
    }
}

---
.\DataAccess\QueryBuilder.cs
---
// File: DynamicSqlEditor/DataAccess/QueryBuilder.cs
using System;
using System.Collections.Generic;
using System.Data; // Required for SqlDbType
using System.Data.SqlClient; // Required for SqlParameter
using System.Linq;
using System.Text;
using System.Windows.Forms; // Contains the desired SortOrder enum
using DynamicSqlEditor.Common;
using DynamicSqlEditor.Configuration.Models;
using DynamicSqlEditor.Schema.Models;

namespace DynamicSqlEditor.DataAccess
{
    public class QueryBuilder
    {
        private readonly TableSchema _tableSchema;
        private readonly TableConfig _tableConfig;

        public QueryBuilder(TableSchema tableSchema, TableConfig tableConfig)
        {
            _tableSchema = tableSchema ?? throw new ArgumentNullException(nameof(tableSchema));
            _tableConfig = tableConfig ?? throw new ArgumentNullException(nameof(tableConfig));
        }

        public string GetSelectQuery()
        {
            if (!string.IsNullOrWhiteSpace(_tableConfig.CustomSelectQuery))
            {
                // Validate custom query contains required placeholders
                if (!_tableConfig.CustomSelectQuery.Contains(Constants.WherePlaceholder) ||
                    !_tableConfig.CustomSelectQuery.Contains(Constants.OrderByPlaceholder) ||
                    !_tableConfig.CustomSelectQuery.Contains(Constants.PagingPlaceholder))
                {
                    throw new InvalidOperationException($"CustomSelectQuery for table '{_tableSchema.SchemaName}.{_tableSchema.TableName}' must contain placeholders: {Constants.WherePlaceholder}, {Constants.OrderByPlaceholder}, {Constants.PagingPlaceholder}");
                }
                return _tableConfig.CustomSelectQuery;
            }
            else
            {
                // Build default query
                var selectableColumns = _tableSchema.Columns
                    .Where(c => !IsComplexType(c.DataType)) // Exclude complex types by default
                    .Select(c => $"[{c.ColumnName}]");

                return $"SELECT {string.Join(", ", selectableColumns)} FROM [{_tableSchema.SchemaName}].[{_tableSchema.TableName}] {Constants.WherePlaceholder} {Constants.OrderByPlaceholder} {Constants.PagingPlaceholder}";
            }
        }

        public string GetWhereClause(FilterDefinition filter)
        {
            return filter?.WhereClause; // Return null if no filter
        }

        // Use fully qualified name for the parameter type
        public string GetOrderByClause(string sortColumn, System.Windows.Forms.SortOrder sortDirection)
        {
            if (string.IsNullOrWhiteSpace(sortColumn))
            {
                // Default to PK if no sort specified
                if (_tableSchema.PrimaryKeys.Any())
                {
                    sortColumn = _tableSchema.PrimaryKeys.First().Column.ColumnName; // Use Column property of PrimaryKeySchema
                                                                                     // Use fully qualified name for the value
                    sortDirection = System.Windows.Forms.SortOrder.Ascending;
                }
                else
                {
                    // If no PK, try the first column as a last resort? Or return null?
                    // Returning null might break paging depending on implementation.
                    // Let's try the first column if available.
                    var firstCol = _tableSchema.Columns.OrderBy(c => c.OrdinalPosition).FirstOrDefault();
                    if (firstCol != null)
                    {
                        sortColumn = firstCol.ColumnName;
                        // Use fully qualified name for the value
                        sortDirection = System.Windows.Forms.SortOrder.Ascending;
                        FileLogger.Warning($"No primary key or explicit sort for {_tableSchema.DisplayName}. Defaulting sort to first column: {sortColumn}. Paging might be unreliable.");
                    }
                    else
                    {
                        FileLogger.Error($"Cannot determine sort order for {_tableSchema.DisplayName}. No PK and no columns found.");
                        return null; // Cannot sort if no column and no PK
                    }
                }
            }

            // Basic validation: Check if sortColumn exists in the schema (or could be from custom query)
            // For simplicity, we assume it's valid here. Robust validation would check against actual selectable columns.
            // Need to handle potential aliases from CustomSelectQuery if sortColumn doesn't match schema directly.
            // Use fully qualified name for the comparison
            string direction = sortDirection == System.Windows.Forms.SortOrder.Descending ? "DESC" : "ASC";

            // Attempt to quote if not already quoted and contains spaces or special chars (basic)
            // A more robust solution would parse the column name properly.
            string quotedSortColumn = sortColumn;
            if (!sortColumn.StartsWith("[") && !sortColumn.EndsWith("]") && (sortColumn.Contains(" ") || sortColumn.Contains("-"))) // Basic check
            {
                quotedSortColumn = $"[{sortColumn}]";
            }
            // If it's already quoted or a simple name, use as is.

            return $"{quotedSortColumn} {direction}";
        }


        public List<SqlParameter> GetFilterParameters(FilterDefinition filter, Dictionary<string, object> inputValues)
        {
            var parameters = new List<SqlParameter>();
            if (filter == null || string.IsNullOrEmpty(filter.RequiresInput) || inputValues == null)
            {
                return parameters;
            }

            // Simple parsing: Assume "ParamName:LookupType" or just "ParamName"
            // And inputValues dictionary keys match ParamName
            string[] requiredParams = filter.RequiresInput.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);

            foreach (string reqParamInfo in requiredParams)
            {
                string paramName = reqParamInfo.Split(':')[0].Trim();
                string sqlParamName = paramName.StartsWith("@") ? paramName : "@" + paramName;

                if (inputValues.TryGetValue(paramName, out object value))
                {
                    // Attempt to infer SqlDbType based on the column the parameter likely relates to.
                    // This is heuristic and might be incorrect, especially with custom filters.
                    // A better approach might involve storing expected type in filter config.
                    SqlDbType? dbType = InferDbTypeFromParameterName(paramName);
                    parameters.Add(SqlParameterHelper.CreateParameter(sqlParamName, value, dbType));
                }
                else
                {
                    // This shouldn't happen if UI ensures values are provided, but log if it does.
                    FileLogger.Warning($"Value for required filter parameter '{paramName}' not found for filter '{filter.Name}'.");
                    // Add parameter with DBNull? Or throw? Adding DBNull might break queries expecting a value.
                    parameters.Add(SqlParameterHelper.CreateParameter(sqlParamName, DBNull.Value));
                }
            }

            return parameters;
        }

        private SqlDbType? InferDbTypeFromParameterName(string paramName)
        {
            // Very basic heuristic: Try to match param name (without @) to a column name
            string columnName = paramName.StartsWith("@") ? paramName.Substring(1) : paramName;
            var matchingColumn = _tableSchema.Columns.FirstOrDefault(c => c.ColumnName.Equals(columnName, StringComparison.OrdinalIgnoreCase));
            return matchingColumn?.GetSqlDbType(); // Returns null if no match or column found
        }


        private bool IsComplexType(string dataType)
        {
            string lowerType = dataType.ToLower();
            return lowerType == "xml" || lowerType == "geography" || lowerType == "geometry" || lowerType == "hierarchyid" || lowerType == "sql_variant";
            // Timestamp/Rowversion is handled separately usually
        }
    }
}

---
.\Models\DataRowWrapper.cs
---
using System;
using System.Collections.Generic;
using System.Data;

namespace DynamicSqlEditor.Models
{
    // Optional helper class if direct DataRow access is cumbersome
    public class DataRowWrapper
    {
        private readonly DataRow _dataRow;

        public DataRowWrapper(DataRow dataRow)
        {
            _dataRow = dataRow ?? throw new ArgumentNullException(nameof(dataRow));
        }

        public object this[string columnName]
        {
            get
            {
                if (_dataRow.Table.Columns.Contains(columnName))
                {
                    return _dataRow[columnName];
                }
                // Handle case where column might not exist (e.g., custom query)
                return null;
            }
            set
            {
                 if (_dataRow.Table.Columns.Contains(columnName))
                {
                    _dataRow[columnName] = value ?? DBNull.Value;
                }
                 // Handle or throw if column doesn't exist?
            }
        }

        public T GetValue<T>(string columnName, T defaultValue = default)
        {
            try
            {
                object value = this[columnName];
                if (value == null || value == DBNull.Value)
                {
                    return defaultValue;
                }
                // Handle potential conversion errors
                return (T)Convert.ChangeType(value, typeof(T));
            }
            catch
            {
                return defaultValue;
            }
        }

        public Dictionary<string, object> ToDictionary()
        {
            var dict = new Dictionary<string, object>(StringComparer.OrdinalIgnoreCase);
            foreach (DataColumn col in _dataRow.Table.Columns)
            {
                dict[col.ColumnName] = _dataRow[col];
            }
            return dict;
        }
    }
}

---
.\Properties\AssemblyInfo.cs
---
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("DynamicSqlEditor")]
[assembly: AssemblyDescription("Dynamic SQL Server Data Browser & Editor")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("DynamicSqlEditor")]
[assembly: AssemblyCopyright("Copyright Â© 2024")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("a1b2c3d4-e5f6-7890-1234-567890abcdef")] // Replace with actual GUID

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]

---
.\Properties\Resources.Designer.cs
---
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace DynamicSqlEditor.Properties {


    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {

        private static global::System.Resources.ResourceManager resourceMan;

        private static global::System.Globalization.CultureInfo resourceCulture;

        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }

        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("DynamicSqlEditor.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }

        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
    }
}

---
.\Properties\Resources.resx
---
ï»¿<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>

---
.\Properties\Settings.Designer.cs
---
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace DynamicSqlEditor.Properties {


    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "17.0.0.0")] // Adjust version as needed
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {

        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));

        public static Settings Default {
            get {
                return defaultInstance;
            }
        }

        // Example setting:
        // [global::System.Configuration.UserScopedSettingAttribute()]
        // [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        // [global::System.Configuration.DefaultSettingValueAttribute("")]
        // public string LastUsedFilter {
        //     get {
        //         return ((string)(this["LastUsedFilter"]));
        //     }
        //     set {
        //         this["LastUsedFilter"] = value;
        //     }
        // }
    }
}

---
.\Properties\Settings.settings
---
ï»¿<?xml version='1.0' encoding='utf-8'?>
<SettingsFile xmlns="http://schemas.microsoft.com/VisualStudio/2004/01/settings" CurrentProfile="(Default)">
  <Profiles>
    <Profile Name="(Default)" />
  </Profiles>
  <Settings />
</SettingsFile>


---
.\Schema\SchemaFilter.cs
---
ï»¿// File: DynamicSqlEditor/Schema/SchemaFilter.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions; // For wildcard matching
using DynamicSqlEditor.Configuration.Models;
using DynamicSqlEditor.Schema.Models;

namespace DynamicSqlEditor.Schema
{
    public static class SchemaFilter
    {
        public static List<TableSchema> FilterTables(List<TableSchema> allTables, GlobalConfig globalConfig)
        {
            if (globalConfig == null)
            {
                return allTables; // No config, return all
            }

            var filteredTables = allTables;

            // 1. Apply IncludeSchemas (if specified)
            if (globalConfig.IncludeSchemas != null && globalConfig.IncludeSchemas.Any())
            {
                filteredTables = filteredTables.Where(table =>
                    globalConfig.IncludeSchemas.Any(includePattern =>
                        MatchesWildcard(table.SchemaName, includePattern))
                ).ToList();
            }

            // 2. Apply ExcludeTables (after includes)
            if (globalConfig.ExcludeTables != null && globalConfig.ExcludeTables.Any())
            {
                filteredTables = filteredTables.Where(table =>
                    !globalConfig.ExcludeTables.Any(excludePattern =>
                        MatchesWildcard($"{table.SchemaName}.{table.TableName}", excludePattern)) // Match against Schema.Table
                ).ToList();
            }

            return filteredTables;
        }

        // Simple wildcard matching supporting *, ?, %
        private static bool MatchesWildcard(string text, string pattern)
        {
            // Convert SQL wildcards to Regex pattern
            // Escape regex special characters except for our wildcards
            string regexPattern = Regex.Escape(pattern)
                                     .Replace(@"\*", ".*")   // * => .* (match zero or more characters)
                                     .Replace(@"\?", ".")    // ? => . (match exactly one character)
                                     .Replace(@"%", ".*");   // % => .* (SQL % is like *)

            // Use Regex for matching (case-insensitive)
            try
            {
                return Regex.IsMatch(text, $"^{regexPattern}$", RegexOptions.IgnoreCase);
            }
            catch (ArgumentException ex)
            {
                // Log invalid pattern from config?
                Common.FileLogger.Warning($"Invalid wildcard pattern '{pattern}' in configuration: {ex.Message}");
                return false; // Treat invalid pattern as non-matching
            }
        }
    }
}

---
.\Schema\SchemaProvider.cs
---
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Linq;
using DynamicSqlEditor.Common;
using DynamicSqlEditor.DataAccess;
using DynamicSqlEditor.Schema.Models;

namespace DynamicSqlEditor.Schema
{
    public class SchemaProvider
    {
        private readonly DatabaseManager _dbManager;

        public SchemaProvider(DatabaseManager dbManager)
        {
            _dbManager = dbManager ?? throw new ArgumentNullException(nameof(dbManager));
        }

        public List<TableSchema> GetAllTables()
        {
            var tables = GetTablesAndViews();
            if (!tables.Any()) return tables;

            var columns = GetColumns(tables);
            var primaryKeys = GetPrimaryKeys(tables);
            var foreignKeys = GetForeignKeys(tables); // Get all FKs at once

            foreach (var table in tables)
            {
                table.Columns.AddRange(columns.Where(c => c.ParentTable == table));
                table.PrimaryKeys.AddRange(primaryKeys.Where(pk => pk.ParentTable == table));
                // Assign FKs where this table is the referencing (child) table
                table.ForeignKeys.AddRange(foreignKeys.Where(fk => fk.ReferencingTable == table));
                // Assign FKs where this table is the referenced (parent) table
                table.ReferencedByForeignKeys.AddRange(foreignKeys.Where(fk => fk.ReferencedTable == table));
            }

            return tables;
        }

        private List<TableSchema> GetTablesAndViews()
        {
            var tables = new List<TableSchema>();
            string sql = @"SELECT TABLE_SCHEMA, TABLE_NAME, TABLE_TYPE FROM INFORMATION_SCHEMA.TABLES
                           WHERE TABLE_TYPE IN ('BASE TABLE', 'VIEW') ORDER BY TABLE_SCHEMA, TABLE_NAME;";
            try
            {
                DataTable dt = _dbManager.ExecuteQueryAsync(sql, null).Result; // Blocking for simplicity here, consider async flow
                foreach (DataRow row in dt.Rows)
                {
                    tables.Add(new TableSchema
                    {
                        SchemaName = row["TABLE_SCHEMA"].ToString(),
                        TableName = row["TABLE_NAME"].ToString(),
                        IsView = row["TABLE_TYPE"].ToString().Equals("VIEW", StringComparison.OrdinalIgnoreCase)
                    });
                }
            }
            catch (Exception ex)
            {
                FileLogger.Error("Failed to retrieve tables and views.", ex);
                throw; // Re-throw to indicate schema loading failure
            }
            return tables;
        }

        private List<ColumnSchema> GetColumns(List<TableSchema> tables)
        {
            var columns = new List<ColumnSchema>();
            string sql = @"
                SELECT
                    c.TABLE_SCHEMA,
                    c.TABLE_NAME,
                    c.COLUMN_NAME,
                    c.ORDINAL_POSITION,
                    c.DATA_TYPE,
                    c.CHARACTER_MAXIMUM_LENGTH,
                    c.NUMERIC_PRECISION,
                    c.NUMERIC_SCALE,
                    c.IS_NULLABLE,
                    COLUMNPROPERTY(OBJECT_ID(c.TABLE_SCHEMA + '.' + c.TABLE_NAME), c.COLUMN_NAME, 'IsIdentity') AS IS_IDENTITY,
                    COLUMNPROPERTY(OBJECT_ID(c.TABLE_SCHEMA + '.' + c.TABLE_NAME), c.COLUMN_NAME, 'IsComputed') AS IS_COMPUTED,
                    CASE WHEN c.DATA_TYPE = 'timestamp' OR c.DATA_TYPE = 'rowversion' THEN 1 ELSE 0 END AS IS_TIMESTAMP
                FROM INFORMATION_SCHEMA.COLUMNS c
                ORDER BY c.TABLE_SCHEMA, c.TABLE_NAME, c.ORDINAL_POSITION;";
            try
            {
                DataTable dt = _dbManager.ExecuteQueryAsync(sql, null).Result;
                foreach (DataRow row in dt.Rows)
                {
                    string schemaName = row["TABLE_SCHEMA"].ToString();
                    string tableName = row["TABLE_NAME"].ToString();
                    var parentTable = tables.FirstOrDefault(t => t.SchemaName == schemaName && t.TableName == tableName);
                    if (parentTable == null) continue; // Skip columns for tables not found (shouldn't happen)

                    columns.Add(new ColumnSchema
                    {
                        ParentTable = parentTable,
                        ColumnName = row["COLUMN_NAME"].ToString(),
                        OrdinalPosition = Convert.ToInt32(row["ORDINAL_POSITION"]),
                        DataType = row["DATA_TYPE"].ToString(),
                        MaxLength = row["CHARACTER_MAXIMUM_LENGTH"] != DBNull.Value ? Convert.ToInt32(row["CHARACTER_MAXIMUM_LENGTH"]) : (int?)null,
                        NumericPrecision = row["NUMERIC_PRECISION"] != DBNull.Value ? Convert.ToInt32(row["NUMERIC_PRECISION"]) : (int?)null,
                        NumericScale = row["NUMERIC_SCALE"] != DBNull.Value ? Convert.ToInt32(row["NUMERIC_SCALE"]) : (int?)null,
                        IsNullable = row["IS_NULLABLE"].ToString().Equals("YES", StringComparison.OrdinalIgnoreCase),
                        IsIdentity = row["IS_IDENTITY"] != DBNull.Value && Convert.ToInt32(row["IS_IDENTITY"]) == 1,
                        IsComputed = row["IS_COMPUTED"] != DBNull.Value && Convert.ToInt32(row["IS_COMPUTED"]) == 1,
                        IsTimestamp = Convert.ToInt32(row["IS_TIMESTAMP"]) == 1
                    });
                }
            }
            catch (Exception ex)
            {
                FileLogger.Error("Failed to retrieve column information.", ex);
                throw;
            }
            return columns;
        }

        private List<PrimaryKeySchema> GetPrimaryKeys(List<TableSchema> tables)
        {
            var primaryKeys = new List<PrimaryKeySchema>();
            string sql = @"
                SELECT
                    kcu.TABLE_SCHEMA,
                    kcu.TABLE_NAME,
                    kcu.COLUMN_NAME,
                    kcu.ORDINAL_POSITION,
                    tc.CONSTRAINT_NAME
                FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu
                JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc
                    ON kcu.CONSTRAINT_NAME = tc.CONSTRAINT_NAME
                    AND kcu.TABLE_SCHEMA = tc.TABLE_SCHEMA
                    AND kcu.TABLE_NAME = tc.TABLE_NAME
                WHERE tc.CONSTRAINT_TYPE = 'PRIMARY KEY'
                ORDER BY kcu.TABLE_SCHEMA, kcu.TABLE_NAME, kcu.ORDINAL_POSITION;";
            try
            {
                DataTable dt = _dbManager.ExecuteQueryAsync(sql, null).Result;
                foreach (DataRow row in dt.Rows)
                {
                     string schemaName = row["TABLE_SCHEMA"].ToString();
                    string tableName = row["TABLE_NAME"].ToString();
                    var parentTable = tables.FirstOrDefault(t => t.SchemaName == schemaName && t.TableName == tableName);
                    if (parentTable == null) continue;

                    var column = parentTable.Columns.FirstOrDefault(c => c.ColumnName == row["COLUMN_NAME"].ToString());
                    if (column == null) continue; // Should have column info already

                    column.IsPrimaryKey = true; // Mark the column as part of PK

                    primaryKeys.Add(new PrimaryKeySchema
                    {
                        ParentTable = parentTable,
                        Column = column,
                        KeyName = row["CONSTRAINT_NAME"].ToString(),
                        OrdinalPosition = Convert.ToInt32(row["ORDINAL_POSITION"])
                    });
                }
            }
            catch (Exception ex)
            {
                FileLogger.Error("Failed to retrieve primary key information.", ex);
                throw;
            }
            return primaryKeys;
        }

        private List<ForeignKeySchema> GetForeignKeys(List<TableSchema> tables)
        {
            var foreignKeys = new List<ForeignKeySchema>();
             string sql = @"
                SELECT
                    fk.name AS FK_Name,
                    ts.name AS Referencing_Schema,
                    tp.name AS Referencing_Table,
                    pc.name AS Referencing_Column,
                    trs.name AS Referenced_Schema,
                    trp.name AS Referenced_Table,
                    rc.name AS Referenced_Column
                FROM sys.foreign_keys AS fk
                INNER JOIN sys.foreign_key_columns AS fkc ON fk.object_id = fkc.constraint_object_id
                INNER JOIN sys.tables AS tp ON fkc.parent_object_id = tp.object_id
                INNER JOIN sys.schemas AS ts ON tp.schema_id = ts.schema_id
                INNER JOIN sys.columns AS pc ON fkc.parent_object_id = pc.object_id AND fkc.parent_column_id = pc.column_id
                INNER JOIN sys.tables AS trp ON fkc.referenced_object_id = trp.object_id
                INNER JOIN sys.schemas AS trs ON trp.schema_id = trs.schema_id
                INNER JOIN sys.columns AS rc ON fkc.referenced_object_id = rc.object_id AND fkc.referenced_column_id = rc.column_id
                ORDER BY Referencing_Schema, Referencing_Table, FK_Name;";
            try
            {
                DataTable dt = _dbManager.ExecuteQueryAsync(sql, null).Result;
                foreach (DataRow row in dt.Rows)
                {
                    string referencingSchema = row["Referencing_Schema"].ToString();
                    string referencingTable = row["Referencing_Table"].ToString();
                    string referencedSchema = row["Referenced_Schema"].ToString();
                    string referencedTable = row["Referenced_Table"].ToString();

                    var parentTable = tables.FirstOrDefault(t => t.SchemaName == referencingSchema && t.TableName == referencingTable);
                    var pkTable = tables.FirstOrDefault(t => t.SchemaName == referencedSchema && t.TableName == referencedTable);

                    if (parentTable == null || pkTable == null) continue; // Skip if tables involved aren't in our list

                    var referencingColumn = parentTable.Columns.FirstOrDefault(c => c.ColumnName == row["Referencing_Column"].ToString());
                    var referencedColumn = pkTable.Columns.FirstOrDefault(c => c.ColumnName == row["Referenced_Column"].ToString());

                    if (referencingColumn == null || referencedColumn == null) continue; // Skip if columns not found

                    referencingColumn.IsForeignKey = true; // Mark the column

                    foreignKeys.Add(new ForeignKeySchema
                    {
                        ConstraintName = row["FK_Name"].ToString(),
                        ReferencingTable = parentTable,
                        ReferencingColumn = referencingColumn,
                        ReferencedTable = pkTable,
                        ReferencedColumn = referencedColumn
                    });
                }
            }
            catch (Exception ex)
            {
                FileLogger.Error("Failed to retrieve foreign key information.", ex);
                throw;
            }
            return foreignKeys;
        }
    }
}

---
.\Schema\Models\ColumnSchema.cs
---
using System.Data; // For SqlDbType

namespace DynamicSqlEditor.Schema.Models
{
    public class ColumnSchema
    {
        public TableSchema ParentTable { get; set; }
        public string ColumnName { get; set; }
        public int OrdinalPosition { get; set; }
        public string DataType { get; set; }
        public int? MaxLength { get; set; }
        public int? NumericPrecision { get; set; }
        public int? NumericScale { get; set; }
        public bool IsNullable { get; set; }
        public bool IsPrimaryKey { get; set; } // Convenience flag
        public bool IsForeignKey { get; set; } // Convenience flag
        public bool IsIdentity { get; set; }
        public bool IsComputed { get; set; }
        public bool IsTimestamp { get; set; } // rowversion or timestamp

        public SqlDbType GetSqlDbType()
        {
            // Basic mapping, needs refinement for specific types
            switch (DataType.ToLower())
            {
                case "bigint": return SqlDbType.BigInt;
                case "binary": return SqlDbType.Binary;
                case "bit": return SqlDbType.Bit;
                case "char": return SqlDbType.Char;
                case "date": return SqlDbType.Date;
                case "datetime": return SqlDbType.DateTime;
                case "datetime2": return SqlDbType.DateTime2;
                case "datetimeoffset": return SqlDbType.DateTimeOffset;
                case "decimal": return SqlDbType.Decimal;
                case "float": return SqlDbType.Float;
                case "geography": return SqlDbType.Udt; // Requires specific UDT handling
                case "geometry": return SqlDbType.Udt; // Requires specific UDT handling
                case "hierarchyid": return SqlDbType.Udt; // Requires specific UDT handling
                case "image": return SqlDbType.Image;
                case "int": return SqlDbType.Int;
                case "money": return SqlDbType.Money;
                case "nchar": return SqlDbType.NChar;
                case "ntext": return SqlDbType.NText;
                case "numeric": return SqlDbType.Decimal; // Often synonymous with decimal
                case "nvarchar": return SqlDbType.NVarChar;
                case "real": return SqlDbType.Real;
                case "rowversion":
                case "timestamp": return SqlDbType.Timestamp;
                case "smalldatetime": return SqlDbType.SmallDateTime;
                case "smallint": return SqlDbType.SmallInt;
                case "smallmoney": return SqlDbType.SmallMoney;
                case "sql_variant": return SqlDbType.Variant;
                case "text": return SqlDbType.Text;
                case "time": return SqlDbType.Time;
                case "tinyint": return SqlDbType.TinyInt;
                case "uniqueidentifier": return SqlDbType.UniqueIdentifier;
                case "varbinary": return SqlDbType.VarBinary;
                case "varchar": return SqlDbType.VarChar;
                case "xml": return SqlDbType.Xml;
                default: return SqlDbType.NVarChar; // Default fallback
            }
        }
    }
}

---
.\Schema\Models\ForeignKeySchema.cs
---
namespace DynamicSqlEditor.Schema.Models
{
    public class ForeignKeySchema
    {
        public string ConstraintName { get; set; }
        public TableSchema ReferencingTable { get; set; } // The table containing the FK column (Child)
        public ColumnSchema ReferencingColumn { get; set; } // The FK column itself
        public TableSchema ReferencedTable { get; set; } // The table the FK points to (Parent)
        public ColumnSchema ReferencedColumn { get; set; } // The PK/Unique column being referenced
    }
}

---
.\Schema\Models\PrimaryKeySchema.cs
---
namespace DynamicSqlEditor.Schema.Models
{
    public class PrimaryKeySchema
    {
        public TableSchema ParentTable { get; set; }
        public ColumnSchema Column { get; set; }
        public string KeyName { get; set; }
        public int OrdinalPosition { get; set; } // For composite keys
    }
}

---
.\Schema\Models\TableSchema.cs
---
using System.Collections.Generic;
using System.Linq;

namespace DynamicSqlEditor.Schema.Models
{
    public class TableSchema
    {
        public string SchemaName { get; set; }
        public string TableName { get; set; }
        public bool IsView { get; set; }
        public List<ColumnSchema> Columns { get; } = new List<ColumnSchema>();
        public List<PrimaryKeySchema> PrimaryKeys { get; } = new List<PrimaryKeySchema>();
        public List<ForeignKeySchema> ForeignKeys { get; } = new List<ForeignKeySchema>(); // FKs defined IN this table
        public List<ForeignKeySchema> ReferencedByForeignKeys { get; } = new List<ForeignKeySchema>(); // FKs in OTHER tables referencing this one

        public string FullName => $"[{SchemaName}].[{TableName}]";
        public string DisplayName => $"{SchemaName}.{TableName}";

        public ColumnSchema GetColumn(string name) => Columns.FirstOrDefault(c => c.ColumnName.Equals(name, System.StringComparison.OrdinalIgnoreCase));
        public PrimaryKeySchema GetPrimaryKey(string columnName) => PrimaryKeys.FirstOrDefault(pk => pk.Column.ColumnName.Equals(columnName, System.StringComparison.OrdinalIgnoreCase));
        public ForeignKeySchema GetForeignKey(string columnName) => ForeignKeys.FirstOrDefault(fk => fk.ReferencingColumn.ColumnName.Equals(columnName, System.StringComparison.OrdinalIgnoreCase));
    }
}

---
.\UI\DataViewForm.Designer.cs
---
namespace DynamicSqlEditor.UI
{
    partial class DataViewForm
    {
        private System.ComponentModel.IContainer components = null;
        private System.Windows.Forms.SplitContainer splitContainer;
        private System.Windows.Forms.Panel topPanel;
        private System.Windows.Forms.Panel filterPanel;
        private System.Windows.Forms.DataGridView mainDataGridView;
        private System.Windows.Forms.Panel pagingPanel;
        private System.Windows.Forms.TabControl relatedDataTabControl;
        private System.Windows.Forms.TabPage detailEditorTab;
        private System.Windows.Forms.Panel detailActionPanel;
        private System.Windows.Forms.Button refreshButton;
        private System.Windows.Forms.Button deleteButton;
        private System.Windows.Forms.Button saveButton;
        private System.Windows.Forms.Button newButton;
        private System.Windows.Forms.Panel detailPanel; // Scrollable panel for fields
        private System.Windows.Forms.Panel actionButtonPanel; // For custom buttons
        private Controls.PagingControl pagingControl; // Custom Paging Control

        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        private void InitializeComponent()
        {
            this.splitContainer = new System.Windows.Forms.SplitContainer();
            this.topPanel = new System.Windows.Forms.Panel();
            this.mainDataGridView = new System.Windows.Forms.DataGridView();
            this.pagingPanel = new System.Windows.Forms.Panel();
            this.pagingControl = new DynamicSqlEditor.UI.Controls.PagingControl();
            this.filterPanel = new System.Windows.Forms.Panel();
            this.relatedDataTabControl = new System.Windows.Forms.TabControl();
            this.detailEditorTab = new System.Windows.Forms.TabPage();
            this.detailPanel = new System.Windows.Forms.Panel();
            this.detailActionPanel = new System.Windows.Forms.Panel();
            this.refreshButton = new System.Windows.Forms.Button();
            this.deleteButton = new System.Windows.Forms.Button();
            this.saveButton = new System.Windows.Forms.Button();
            this.newButton = new System.Windows.Forms.Button();
            this.actionButtonPanel = new System.Windows.Forms.Panel();
            ((System.ComponentModel.ISupportInitialize)(this.splitContainer)).BeginInit();
            this.splitContainer.Panel1.SuspendLayout();
            this.splitContainer.Panel2.SuspendLayout();
            this.splitContainer.SuspendLayout();
            this.topPanel.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.mainDataGridView)).BeginInit();
            this.pagingPanel.SuspendLayout();
            this.relatedDataTabControl.SuspendLayout();
            this.detailEditorTab.SuspendLayout();
            this.detailActionPanel.SuspendLayout();
            this.SuspendLayout();
            //
            // splitContainer
            //
            this.splitContainer.Dock = System.Windows.Forms.DockStyle.Fill;
            this.splitContainer.Location = new System.Drawing.Point(0, 0);
            this.splitContainer.Name = "splitContainer";
            this.splitContainer.Orientation = System.Windows.Forms.Orientation.Horizontal;
            //
            // splitContainer.Panel1
            //
            this.splitContainer.Panel1.Controls.Add(this.topPanel);
            //
            // splitContainer.Panel2
            //
            this.splitContainer.Panel2.Controls.Add(this.relatedDataTabControl);
            this.splitContainer.Panel2.Controls.Add(this.actionButtonPanel);
            this.splitContainer.Size = new System.Drawing.Size(784, 561);
            this.splitContainer.SplitterDistance = 280;
            this.splitContainer.TabIndex = 0;
            //
            // topPanel
            //
            this.topPanel.Controls.Add(this.mainDataGridView);
            this.topPanel.Controls.Add(this.pagingPanel);
            this.topPanel.Controls.Add(this.filterPanel);
            this.topPanel.Dock = System.Windows.Forms.DockStyle.Fill;
            this.topPanel.Location = new System.Drawing.Point(0, 0);
            this.topPanel.Name = "topPanel";
            this.topPanel.Size = new System.Drawing.Size(784, 280);
            this.topPanel.TabIndex = 0;
            //
            // mainDataGridView
            //
            this.mainDataGridView.ColumnHeadersHeightSizeMode = System.Windows.Forms.DataGridViewColumnHeadersHeightSizeMode.AutoSize;
            this.mainDataGridView.Dock = System.Windows.Forms.DockStyle.Fill;
            this.mainDataGridView.Location = new System.Drawing.Point(0, 35); // Height of filterPanel
            this.mainDataGridView.Name = "mainDataGridView";
            this.mainDataGridView.Size = new System.Drawing.Size(784, 210); // Height of topPanel - filterPanel - pagingPanel
            this.mainDataGridView.TabIndex = 1;
            //
            // pagingPanel
            //
            this.pagingPanel.Controls.Add(this.pagingControl);
            this.pagingPanel.Dock = System.Windows.Forms.DockStyle.Bottom;
            this.pagingPanel.Location = new System.Drawing.Point(0, 245); // Positioned at bottom
            this.pagingPanel.Name = "pagingPanel";
            this.pagingPanel.Size = new System.Drawing.Size(784, 35);
            this.pagingPanel.TabIndex = 2;
            //
            // pagingControl
            //
            this.pagingControl.AutoSize = true;
            this.pagingControl.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;
            this.pagingControl.CurrentPage = 1;
            this.pagingControl.Dock = System.Windows.Forms.DockStyle.Fill; // Fill the panel
            this.pagingControl.Location = new System.Drawing.Point(0, 0);
            this.pagingControl.Margin = new System.Windows.Forms.Padding(0);
            this.pagingControl.Name = "pagingControl";
            this.pagingControl.PageSize = 50;
            this.pagingControl.Size = new System.Drawing.Size(784, 35);
            this.pagingControl.TabIndex = 0;
            this.pagingControl.TotalPages = 0;
            this.pagingControl.TotalRecords = 0;
            //
            // filterPanel
            //
            this.filterPanel.Dock = System.Windows.Forms.DockStyle.Top;
            this.filterPanel.Location = new System.Drawing.Point(0, 0);
            this.filterPanel.Name = "filterPanel";
            this.filterPanel.Padding = new System.Windows.Forms.Padding(5);
            this.filterPanel.Size = new System.Drawing.Size(784, 35);
            this.filterPanel.TabIndex = 0;
            //
            // relatedDataTabControl
            //
            this.relatedDataTabControl.Controls.Add(this.detailEditorTab);
            this.relatedDataTabControl.Dock = System.Windows.Forms.DockStyle.Fill;
            this.relatedDataTabControl.Location = new System.Drawing.Point(0, 0);
            this.relatedDataTabControl.Name = "relatedDataTabControl";
            this.relatedDataTabControl.SelectedIndex = 0;
            this.relatedDataTabControl.Size = new System.Drawing.Size(784, 242); // Fill Panel2 above actionButtonPanel
            this.relatedDataTabControl.TabIndex = 0;
            //
            // detailEditorTab
            //
            this.detailEditorTab.Controls.Add(this.detailPanel);
            this.detailEditorTab.Controls.Add(this.detailActionPanel);
            this.detailEditorTab.Location = new System.Drawing.Point(4, 22);
            this.detailEditorTab.Name = "detailEditorTab";
            this.detailEditorTab.Padding = new System.Windows.Forms.Padding(3);
            this.detailEditorTab.Size = new System.Drawing.Size(776, 216); // Adjusted size
            this.detailEditorTab.TabIndex = 0;
            this.detailEditorTab.Text = "Details";
            this.detailEditorTab.UseVisualStyleBackColor = true;
            //
            // detailPanel
            //
            this.detailPanel.AutoScroll = true;
            this.detailPanel.Dock = System.Windows.Forms.DockStyle.Fill;
            this.detailPanel.Location = new System.Drawing.Point(3, 3);
            this.detailPanel.Name = "detailPanel";
            this.detailPanel.Padding = new System.Windows.Forms.Padding(5);
            this.detailPanel.Size = new System.Drawing.Size(770, 175); // Fill above detailActionPanel
            this.detailPanel.TabIndex = 1;
            //
            // detailActionPanel
            //
            this.detailActionPanel.Controls.Add(this.refreshButton);
            this.detailActionPanel.Controls.Add(this.deleteButton);
            this.detailActionPanel.Controls.Add(this.saveButton);
            this.detailActionPanel.Controls.Add(this.newButton);
            this.detailActionPanel.Dock = System.Windows.Forms.DockStyle.Bottom;
            this.detailActionPanel.Location = new System.Drawing.Point(3, 178); // Positioned at bottom of tab
            this.detailActionPanel.Name = "detailActionPanel";
            this.detailActionPanel.Size = new System.Drawing.Size(770, 35);
            this.detailActionPanel.TabIndex = 0;
            //
            // refreshButton
            //
            this.refreshButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
            this.refreshButton.Location = new System.Drawing.Point(689, 6);
            this.refreshButton.Name = "refreshButton";
            this.refreshButton.Size = new System.Drawing.Size(75, 23);
            this.refreshButton.TabIndex = 3;
            this.refreshButton.Text = "&Refresh";
            this.refreshButton.UseVisualStyleBackColor = true;
            //
            // deleteButton
            //
            this.deleteButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
            this.deleteButton.Location = new System.Drawing.Point(608, 6);
            this.deleteButton.Name = "deleteButton";
            this.deleteButton.Size = new System.Drawing.Size(75, 23);
            this.deleteButton.TabIndex = 2;
            this.deleteButton.Text = "&Delete";
            this.deleteButton.UseVisualStyleBackColor = true;
            //
            // saveButton
            //
            this.saveButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
            this.saveButton.Enabled = false;
            this.saveButton.Location = new System.Drawing.Point(527, 6);
            this.saveButton.Name = "saveButton";
            this.saveButton.Size = new System.Drawing.Size(75, 23);
            this.saveButton.TabIndex = 1;
            this.saveButton.Text = "&Save";
            this.saveButton.UseVisualStyleBackColor = true;
            //
            // newButton
            //
            this.newButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
            this.newButton.Location = new System.Drawing.Point(446, 6);
            this.newButton.Name = "newButton";
            this.newButton.Size = new System.Drawing.Size(75, 23);
            this.newButton.TabIndex = 0;
            this.newButton.Text = "&New";
            this.newButton.UseVisualStyleBackColor = true;
            //
            // actionButtonPanel
            //
            this.actionButtonPanel.Dock = System.Windows.Forms.DockStyle.Bottom;
            this.actionButtonPanel.Location = new System.Drawing.Point(0, 242); // Below TabControl
            this.actionButtonPanel.Name = "actionButtonPanel";
            this.actionButtonPanel.Padding = new System.Windows.Forms.Padding(5);
            this.actionButtonPanel.Size = new System.Drawing.Size(784, 35);
            this.actionButtonPanel.TabIndex = 1;
            //
            // DataViewForm
            //
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(784, 561);
            this.Controls.Add(this.splitContainer);
            this.Name = "DataViewForm";
            this.Text = "Data View"; // Will be set dynamically
            this.splitContainer.Panel1.ResumeLayout(false);
            this.splitContainer.Panel2.ResumeLayout(false);
            ((System.ComponentModel.ISupportInitialize)(this.splitContainer)).EndInit();
            this.splitContainer.ResumeLayout(false);
            this.topPanel.ResumeLayout(false);
            ((System.ComponentModel.ISupportInitialize)(this.mainDataGridView)).EndInit();
            this.pagingPanel.ResumeLayout(false);
            this.pagingPanel.PerformLayout();
            this.relatedDataTabControl.ResumeLayout(false);
            this.detailEditorTab.ResumeLayout(false);
            this.detailActionPanel.ResumeLayout(false);
            this.ResumeLayout(false);

        }
    }
}

---
.\UI\DataViewForm.cs
---
// File: DynamicSqlEditor/UI/DataViewForm.cs
using System;
using System.Collections.Generic;
using System.Data;
using System.Diagnostics;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Windows.Forms;
using DynamicSqlEditor.Common;
using DynamicSqlEditor.Configuration.Models;
using DynamicSqlEditor.Core;
using DynamicSqlEditor.DataAccess;
using DynamicSqlEditor.Schema.Models;
using DynamicSqlEditor.UI.Builders;
using DynamicSqlEditor.UI.Controls;
using DynamicSqlEditor.UI.Dialogs;

namespace DynamicSqlEditor.UI
{
    public partial class DataViewForm : Form
    {
        private readonly StateManager _stateManager;
        private readonly TableConfig _tableConfig;
        private readonly GlobalConfig _globalConfig;
        private readonly DynamicSqlEditor.Core.DataViewManager _dataViewManager;
        private readonly CrudManager _crudManager;
        private readonly ConcurrencyHandler _concurrencyHandler;

        private BindingSource _bindingSource;
        private DetailFormBuilder _detailBuilder; // <-- Add field for the builder instance
        private bool _isDirty = false;
        private bool _isNewRecord = false;
        private bool _isLoading = false;
        private Dictionary<string, object> _originalKeyValues;

        public TableSchema TableSchema { get; }
        public event Action<object, string> StatusChanged;

        public bool IsDirty
        {
            get => _isDirty;
            private set
            {
                if (_isDirty != value)
                {
                    _isDirty = value;
                    UpdateTitle();
                    saveButton.Enabled = _isDirty;
                }
            }
        }

        public DataViewForm(StateManager stateManager, TableSchema tableSchema)
        {
            InitializeComponent();

            _stateManager = stateManager ?? throw new ArgumentNullException(nameof(stateManager));
            TableSchema = tableSchema ?? throw new ArgumentNullException(nameof(tableSchema));
            _tableConfig = _stateManager.ConfigManager.GetTableConfig(TableSchema.SchemaName, TableSchema.TableName);
            _globalConfig = _stateManager.ConfigManager.CurrentConfig.Global;

            _dataViewManager = new DynamicSqlEditor.Core.DataViewManager(_stateManager.DbManager, TableSchema, _tableConfig);
            _crudManager = new CrudManager(_stateManager.DbManager, TableSchema);
            _concurrencyHandler = new ConcurrencyHandler(TableSchema);

            this.Text = TableSchema.DisplayName;
            _bindingSource = new BindingSource();

            // Wire up events
            this.Load += DataViewForm_Load;
            this.FormClosing += DataViewForm_FormClosing;
            mainDataGridView.SelectionChanged += MainDataGridView_SelectionChanged;
            mainDataGridView.ColumnHeaderMouseClick += MainDataGridView_ColumnHeaderMouseClick;
            mainDataGridView.DataError += MainDataGridView_DataError;
            _bindingSource.CurrentChanged += BindingSource_CurrentChanged;

            // Paging Control Events
            pagingControl.FirstPageClicked += async (s, e) => await NavigatePaging(_dataViewManager.FirstPageAsync);
            pagingControl.PreviousPageClicked += async (s, e) => await NavigatePaging(_dataViewManager.PreviousPageAsync);
            pagingControl.NextPageClicked += async (s, e) => await NavigatePaging(_dataViewManager.NextPageAsync);
            pagingControl.LastPageClicked += async (s, e) => await NavigatePaging(_dataViewManager.LastPageAsync);
            pagingControl.PageSizeChanged += async (s, newSize) => {
                _dataViewManager.PageSize = newSize;
                await LoadDataAsync(1);
            };


            // Detail Action Buttons
            newButton.Click += NewButton_Click;
            saveButton.Click += async (s, e) => await SaveButton_ClickAsync();
            deleteButton.Click += async (s, e) => await DeleteButton_ClickAsync();
            refreshButton.Click += async (s, e) => await RefreshButton_ClickAsync();

            // Related Tabs Lazy Loading
            relatedDataTabControl.SelectedIndexChanged += RelatedDataTabControl_SelectedIndexChanged;
        }

        private async void DataViewForm_Load(object sender, EventArgs e)
        {
            if (_isLoading) return;
            _isLoading = true;
            this.Cursor = Cursors.WaitCursor;
            OnStatusChanged($"Loading {TableSchema.DisplayName}...");

            try
            {
                // 1. Build Static UI Parts (Filters, Detail Panel Structure, Related Tabs Structure, Action Buttons)
                BuildFilterUI();
                await BuildDetailPanelAsync(); // This now assigns _detailBuilder
                BuildRelatedTabs();
                BuildActionButtons();

                // 2. Initial Data Load
                await LoadDataAsync(1);

                // 3. Set initial state
                SetEditMode(false); // Start in view mode
                IsDirty = false; // Ensure clean state initially
                saveButton.Enabled = false;
                deleteButton.Enabled = _bindingSource.Current != null;
            }
            catch (Exception ex)
            {
                HandleError($"Error loading data view for {TableSchema.DisplayName}", ex);
            }
            finally
            {
                _isLoading = false;
                this.Cursor = Cursors.Default;
                OnStatusChanged($"Ready - {TableSchema.DisplayName}");
            }
        }

        private void BuildFilterUI()
        {
            var filterBuilder = new FilterUIBuilder(filterPanel, _tableConfig);
            filterBuilder.BuildFilters(FilterComboBox_SelectedIndexChanged);
        }

        private async Task BuildDetailPanelAsync()
        {
            // Create and store the builder instance
            _detailBuilder = new DetailFormBuilder(detailPanel, TableSchema, _tableConfig, _globalConfig, _stateManager, _dataViewManager);
            await _detailBuilder.BuildFormAsync(Control_ValueChanged);
        }

        private void BuildRelatedTabs()
        {
            var relatedTabsBuilder = new RelatedTabsBuilder(relatedDataTabControl, TableSchema, _tableConfig, _stateManager.DbManager);
            relatedTabsBuilder.BuildTabs();
        }

        private void BuildActionButtons()
        {
            var actionButtonBuilder = new ActionButtonBuilder(actionButtonPanel, _tableConfig, _globalConfig);
            actionButtonBuilder.BuildButtons(ActionButton_Click);
        }

        private async Task LoadDataAsync(int pageNumber)
        {
            if (_isLoading) return;
            if (IsDirty && !PromptSaveChanges()) return;

            _isLoading = true;
            this.Cursor = Cursors.WaitCursor;
            mainDataGridView.DataSource = null;
            OnStatusChanged($"Loading page {pageNumber} for {TableSchema.DisplayName}...");

            try
            {
                var (data, totalRecords) = await _dataViewManager.LoadDataAsync(pageNumber);

                _bindingSource.DataSource = data;
                mainDataGridView.DataSource = _bindingSource;

                ConfigureGridView();

                pagingControl.UpdatePagingInfo(_dataViewManager.CurrentPage, _dataViewManager.TotalPages, _dataViewManager.TotalRecords, _dataViewManager.PageSize);
                UpdateStatusAndControlStates();
            }
            catch (Exception ex)
            {
                HandleError($"Failed to load data for {TableSchema.DisplayName}", ex);
                pagingControl.UpdatePagingInfo(1, 0, 0, _dataViewManager.PageSize);
            }
            finally
            {
                _isLoading = false;
                this.Cursor = Cursors.Default;
                OnStatusChanged($"Page {_dataViewManager.CurrentPage} of {_dataViewManager.TotalPages} ({_dataViewManager.TotalRecords} records) - {TableSchema.DisplayName}");
            }
        }

        private void ConfigureGridView()
        {
            mainDataGridView.AllowUserToAddRows = false;
            mainDataGridView.AllowUserToDeleteRows = false;
            mainDataGridView.ReadOnly = true;
            mainDataGridView.AutoSizeColumnsMode = DataGridViewAutoSizeColumnsMode.DisplayedCells;
            mainDataGridView.SelectionMode = DataGridViewSelectionMode.FullRowSelect;
            mainDataGridView.MultiSelect = false;

            foreach (DataGridViewColumn gridCol in mainDataGridView.Columns)
            {
                if (_tableConfig.DetailFormFields.TryGetValue(gridCol.Name, out var fieldConfig) && !string.IsNullOrEmpty(fieldConfig.Label))
                {
                    gridCol.HeaderText = fieldConfig.Label;
                }

                if (gridCol.ValueType == typeof(DateTime))
                {
                    gridCol.DefaultCellStyle.Format = Constants.DefaultDateTimeFormat;
                }
                else if (gridCol.ValueType == typeof(decimal) || gridCol.ValueType == typeof(double) || gridCol.ValueType == typeof(float))
                {
                    gridCol.DefaultCellStyle.Format = "N2";
                }

                var schemaCol = TableSchema.GetColumn(gridCol.Name);
                bool isVisibleConfig = !_tableConfig.DetailFormFields.TryGetValue(gridCol.Name, out var cfg) || (cfg.Visible ?? true);
                bool isComplex = schemaCol != null && (schemaCol.DataType.ToLower() == "xml" || schemaCol.DataType.ToLower() == "geography" || schemaCol.DataType.ToLower() == "geometry" || schemaCol.DataType.ToLower() == "hierarchyid");

                gridCol.Visible = isVisibleConfig && !isComplex;
            }
        }

        private void UpdateStatusAndControlStates()
        {
            bool hasRecords = _dataViewManager.TotalRecords > 0;
            bool recordSelected = _bindingSource.Current != null;

            deleteButton.Enabled = recordSelected && !_isNewRecord;
            saveButton.Enabled = IsDirty;

            foreach (Control c in actionButtonPanel.Controls)
            {
                if (c is Button btn && btn.Tag is ActionButtonDefinition actionDef)
                {
                    btn.Enabled = !actionDef.RequiresSelection || recordSelected;
                }
            }
        }

        private void MainDataGridView_SelectionChanged(object sender, EventArgs e)
        {
            // Handled by BindingSource_CurrentChanged
        }

        private void BindingSource_CurrentChanged(object sender, EventArgs e)
        {
            if (_isLoading) return;

            if (IsDirty && !PromptSaveChanges())
            {
                FileLogger.Warning("Selection changed while dirty, but user cancelled save/discard.");
            }

            PopulateDetailPanel(); // Calls instance method on _detailBuilder
            ClearRelatedTabsData();
            LoadDataForVisibleRelatedTab();
            UpdateStatusAndControlStates();
        }

        // Calls instance method on _detailBuilder
        private void PopulateDetailPanel()
        {
            var currentView = _bindingSource.Current as DataRowView;
            _originalKeyValues = null;

            if (_detailBuilder == null) return; // Guard against calls before builder is created

            if (currentView == null || _isNewRecord)
            {
                _detailBuilder.ClearControls(); // Use instance method
                SetEditMode(true);
                return;
            }

            SetEditMode(false);
            _originalKeyValues = GetKeyValues(currentView);
            _detailBuilder.PopulateControls(currentView); // Use instance method
        }

        private Dictionary<string, object> GetKeyValues(DataRowView rowView)
        {
            var keyValues = new Dictionary<string, object>();
            if (rowView == null) return keyValues;

            foreach (var pk in TableSchema.PrimaryKeys)
            {
                if (rowView.Row.Table.Columns.Contains(pk.Column.ColumnName))
                {
                    keyValues[pk.Column.ColumnName] = rowView[pk.Column.ColumnName];
                }
                else
                {
                    FileLogger.Error($"Primary key column '{pk.Column.ColumnName}' not found in data source for table {TableSchema.DisplayName}.");
                }
            }
            return keyValues;
        }

        // Calls instance method on _detailBuilder
        private void SetEditMode(bool enabled)
        {
            if (_detailBuilder == null) return; // Guard

            _detailBuilder.SetControlsEnabled(enabled); // Use instance method
            mainDataGridView.Enabled = !enabled;
            filterPanel.Enabled = !enabled;
            pagingControl.Enabled = !enabled;
            newButton.Enabled = !enabled;
            deleteButton.Enabled = !enabled && _bindingSource.Current != null;
            refreshButton.Enabled = !enabled;
        }

        private void Control_ValueChanged(object sender, EventArgs e)
        {
            if (_isLoading) return;

            if (sender is CheckBox isNullChk && isNullChk.Tag?.ToString() == "IsNullCheckBox")
            {
                var relatedControl = detailPanel.Controls.OfType<Control>().FirstOrDefault(c => c.Name == isNullChk.Name.Replace("IsNullChk_", ""));
                if (relatedControl != null)
                {
                    relatedControl.Enabled = !isNullChk.Checked;
                    if (isNullChk.Checked && relatedControl is ComboBox cmb) cmb.SelectedIndex = -1;
                    if (isNullChk.Checked && relatedControl is NullableDateTimePicker dtp) dtp.Value = null;
                }
            }

            if (!_isNewRecord && !IsDirty)
            {
                IsDirty = true;
            }
            else if (_isNewRecord)
            {
                IsDirty = true;
            }

            if (IsDirty && !_isNewRecord) SetEditMode(true);
        }


        private void NewButton_Click(object sender, EventArgs e)
        {
            if (IsDirty && !PromptSaveChanges()) return;
            if (_detailBuilder == null) return; // Guard

            _isNewRecord = true;
            IsDirty = false;
            _bindingSource.SuspendBinding();
            mainDataGridView.ClearSelection();
            mainDataGridView.Enabled = false;
            filterPanel.Enabled = false;
            pagingControl.Enabled = false;

            _detailBuilder.ClearControls(); // Use instance method
            SetEditMode(true);
            UpdateTitle();
            saveButton.Enabled = false;
            deleteButton.Enabled = false;
            refreshButton.Enabled = false;

            detailPanel.Controls.OfType<Control>().FirstOrDefault()?.Focus();
            OnStatusChanged($"Entering new record for {TableSchema.DisplayName}...");
        }

        private async Task SaveButton_ClickAsync()
        {
            if (!IsDirty || _detailBuilder == null) return; // Guard

            this.Cursor = Cursors.WaitCursor;
            OnStatusChanged($"Saving record for {TableSchema.DisplayName}...");

            try
            {
                var columnValues = _detailBuilder.GetControlValues(); // Use instance method

                if (!ValidateInput(columnValues))
                {
                    this.Cursor = Cursors.Default;
                    OnStatusChanged($"Validation failed. Please check input. - {TableSchema.DisplayName}");
                    return;
                }


                if (_isNewRecord)
                {
                    await _crudManager.InsertRecordAsync(columnValues);
                    OnStatusChanged($"New record saved successfully for {TableSchema.DisplayName}.");
                }
                else
                {
                    object originalTimestamp = _concurrencyHandler.GetTimestampValue(_bindingSource.Current as DataRowView);
                    int rowsAffected = await _crudManager.UpdateRecordAsync(columnValues, _originalKeyValues, originalTimestamp);
                    if (rowsAffected > 0)
                    {
                        OnStatusChanged($"Record updated successfully for {TableSchema.DisplayName}.");
                    }
                    else
                    {
                        OnStatusChanged($"Record update may not have completed (0 rows affected). - {TableSchema.DisplayName}");
                    }
                }

                _isNewRecord = false;
                IsDirty = false;
                SetEditMode(false);
                _bindingSource.ResumeBinding();

                await RefreshDataAsync(true);
            }
            catch (DBConcurrencyException ex)
            {
                HandleConcurrencyError(ex);
            }
            catch (Exception ex)
            {
                HandleError($"Error saving record for {TableSchema.DisplayName}", ex);
            }
            finally
            {
                this.Cursor = Cursors.Default;
            }
        }

        private bool ValidateInput(Dictionary<string, object> columnValues)
        {
            var errors = new List<string>();
            foreach (var col in TableSchema.Columns)
            {
                if (!col.IsNullable && !col.IsIdentity && !col.IsComputed && !col.IsTimestamp)
                {
                    if (!columnValues.TryGetValue(col.ColumnName, out var value) || value == null || value == DBNull.Value)
                    {
                        string labelText = col.ColumnName;
                        if (_tableConfig.DetailFormFields.TryGetValue(col.ColumnName, out var fieldCfg) && !string.IsNullOrEmpty(fieldCfg.Label))
                        {
                            labelText = fieldCfg.Label;
                        }
                        errors.Add($"'{labelText}' cannot be empty.");
                    }
                }

                if (col.MaxLength.HasValue && col.MaxLength > 0 && columnValues.TryGetValue(col.ColumnName, out var strValue) && strValue is string s && s.Length > col.MaxLength.Value)
                {
                    string labelText = col.ColumnName;
                    if (_tableConfig.DetailFormFields.TryGetValue(col.ColumnName, out var fieldCfg) && !string.IsNullOrEmpty(fieldCfg.Label)) labelText = fieldCfg.Label;
                    errors.Add($"'{labelText}' exceeds maximum length of {col.MaxLength.Value}.");
                }
            }

            if (errors.Any())
            {
                MessageBox.Show("Please correct the following errors:\n\n" + string.Join("\n", errors), "Validation Error", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                return false;
            }
            return true;
        }


        private async Task DeleteButton_ClickAsync()
        {
            var currentView = _bindingSource.Current as DataRowView;
            if (currentView == null || _isNewRecord) return;

            var result = MessageBox.Show("Are you sure you want to delete the current record?", "Confirm Delete", MessageBoxButtons.YesNo, MessageBoxIcon.Warning);
            if (result != DialogResult.Yes) return;

            this.Cursor = Cursors.WaitCursor;
            OnStatusChanged($"Deleting record from {TableSchema.DisplayName}...");

            try
            {
                var keyValues = GetKeyValues(currentView);
                object originalTimestamp = _concurrencyHandler.GetTimestampValue(currentView);

                await _crudManager.DeleteRecordAsync(keyValues, originalTimestamp);

                IsDirty = false;
                OnStatusChanged($"Record deleted successfully from {TableSchema.DisplayName}.");

                await RefreshDataAsync(true);
            }
            catch (DBConcurrencyException ex)
            {
                HandleConcurrencyError(ex);
            }
            catch (Exception ex)
            {
                HandleError($"Error deleting record from {TableSchema.DisplayName}", ex);
            }
            finally
            {
                this.Cursor = Cursors.Default;
            }
        }

        private async Task RefreshButton_ClickAsync()
        {
            await RefreshDataAsync(false);
        }

        private async Task RefreshDataAsync(bool force = false)
        {
            if (!force && IsDirty && !PromptSaveChanges()) return;

            await LoadDataAsync(_dataViewManager.CurrentPage);
        }

        private async void FilterComboBox_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (_isLoading || !(sender is ComboBox cmb) || cmb.SelectedItem == null) return;

            FilterDefinition selectedFilter = null;
            Dictionary<string, object> filterParams = null;

            if (cmb.SelectedItem is KeyValuePair<string, FilterDefinition> kvp)
            {
                selectedFilter = kvp.Value;
            }
            else if (cmb.SelectedItem.ToString() == FilterUIBuilder.ClearFilterText)
            {
                selectedFilter = null;
            }

            if (selectedFilter != null && !string.IsNullOrEmpty(selectedFilter.RequiresInput))
            {
                using (var inputDialog = new FilterInputDialog(selectedFilter, _dataViewManager))
                {
                    if (inputDialog.ShowDialog(this) == DialogResult.OK)
                    {
                        filterParams = inputDialog.GetInputValues();
                    }
                    else
                    {
                        cmb.SelectedIndexChanged -= FilterComboBox_SelectedIndexChanged;
                        if (_dataViewManager.CurrentFilter != null)
                        {
                            var filterItem = cmb.Items.OfType<KeyValuePair<string, FilterDefinition>>()
                                .FirstOrDefault(item => item.Value == _dataViewManager.CurrentFilter);
                            cmb.SelectedItem = filterItem;
                        }
                        else
                        {
                            var clearItem = cmb.Items.OfType<string>()
                                .FirstOrDefault(item => item == FilterUIBuilder.ClearFilterText);
                            cmb.SelectedItem = clearItem;
                        }
                        cmb.SelectedIndexChanged += FilterComboBox_SelectedIndexChanged;
                        return;
                    }
                }
            }

            this.Cursor = Cursors.WaitCursor;
            OnStatusChanged($"Applying filter '{selectedFilter?.Label ?? "None"}'...");
            try
            {
                if (selectedFilter != null)
                {
                    await _dataViewManager.ApplyFilterAsync(selectedFilter, filterParams);
                }
                else
                {
                    await _dataViewManager.ClearFilterAsync();
                }
            }
            catch (Exception ex)
            {
                HandleError($"Error applying filter '{selectedFilter?.Label ?? "None"}'", ex);
                this.Cursor = Cursors.Default;
                OnStatusChanged($"Error applying filter. Ready. - {TableSchema.DisplayName}");
            }
        }


        private async void MainDataGridView_ColumnHeaderMouseClick(object sender, DataGridViewCellMouseEventArgs e)
        {
            if (_isLoading || IsDirty) return;

            string columnName = mainDataGridView.Columns[e.ColumnIndex].DataPropertyName;

            this.Cursor = Cursors.WaitCursor;
            OnStatusChanged($"Sorting by {columnName}...");
            try
            {
                await _dataViewManager.ApplySortAsync(columnName);
            }
            catch (Exception ex)
            {
                HandleError($"Error sorting by column {columnName}", ex);
                this.Cursor = Cursors.Default;
                OnStatusChanged($"Error sorting. Ready. - {TableSchema.DisplayName}");
            }
        }

        private async Task NavigatePaging(Func<Task<(DataTable Data, int TotalRecords)>> navigationAction)
        {
            if (_isLoading) return;
            if (IsDirty && !PromptSaveChanges()) return;

            _isLoading = true;
            this.Cursor = Cursors.WaitCursor;
            mainDataGridView.DataSource = null;
            OnStatusChanged($"Navigating data for {TableSchema.DisplayName}...");

            try
            {
                var (data, totalRecords) = await navigationAction();

                _bindingSource.DataSource = data;
                mainDataGridView.DataSource = _bindingSource;

                pagingControl.UpdatePagingInfo(_dataViewManager.CurrentPage, _dataViewManager.TotalPages, _dataViewManager.TotalRecords, _dataViewManager.PageSize);
                UpdateStatusAndControlStates();
            }
            catch (Exception ex)
            {
                HandleError($"Failed to navigate data for {TableSchema.DisplayName}", ex);
            }
            finally
            {
                _isLoading = false;
                this.Cursor = Cursors.Default;
                OnStatusChanged($"Page {_dataViewManager.CurrentPage} of {_dataViewManager.TotalPages} ({_dataViewManager.TotalRecords} records) - {TableSchema.DisplayName}");
            }
        }

        private void RelatedDataTabControl_SelectedIndexChanged(object sender, EventArgs e)
        {
            LoadDataForVisibleRelatedTab();
        }

        private async void LoadDataForVisibleRelatedTab()
        {
            if (_isLoading || relatedDataTabControl.SelectedIndex <= 0)
            {
                return;
            }

            var selectedTab = relatedDataTabControl.SelectedTab;
            if (selectedTab == null || !(selectedTab.Tag is RelatedChildDefinition relatedConfig) || !(selectedTab.Controls[0] is DataGridView relatedGrid))
            {
                return;
            }

            if (relatedGrid.DataSource != null && relatedGrid.Rows.Count > 0)
            {
                return;
            }

            var currentMasterView = _bindingSource.Current as DataRowView;
            if (currentMasterView == null)
            {
                relatedGrid.DataSource = null;
                return;
            }

            this.Cursor = Cursors.WaitCursor;
            OnStatusChanged($"Loading related data: {relatedConfig.Label}...");
            relatedGrid.DataSource = null;

            try
            {
                var parentKeyValues = GetKeyValues(currentMasterView);
                if (parentKeyValues.Count == 0)
                {
                    FileLogger.Warning($"Cannot load related data for '{relatedConfig.Label}': Parent key values could not be determined.");
                    return;
                }

                DataTable relatedData = await _dataViewManager.GetRelatedDataAsync(relatedConfig, parentKeyValues);
                relatedGrid.DataSource = relatedData;

                relatedGrid.ReadOnly = true;
                relatedGrid.AllowUserToAddRows = false;
                relatedGrid.AllowUserToDeleteRows = false;
                relatedGrid.AutoSizeColumnsMode = DataGridViewAutoSizeColumnsMode.DisplayedCells;
                relatedGrid.SelectionMode = DataGridViewSelectionMode.FullRowSelect;
                relatedGrid.MultiSelect = false;

                OnStatusChanged($"Loaded related data: {relatedConfig.Label}. Ready. - {TableSchema.DisplayName}");
            }
            catch (Exception ex)
            {
                HandleError($"Error loading related data for tab '{relatedConfig.Label}'", ex);
                OnStatusChanged($"Error loading related data: {relatedConfig.Label}. Ready. - {TableSchema.DisplayName}");
            }
            finally
            {
                this.Cursor = Cursors.Default;
            }
        }

        private void ClearRelatedTabsData()
        {
            foreach (TabPage tabPage in relatedDataTabControl.TabPages)
            {
                if (tabPage.Tag is RelatedChildDefinition && tabPage.Controls.Count > 0 && tabPage.Controls[0] is DataGridView relatedGrid)
                {
                    relatedGrid.DataSource = null;
                }
            }
        }

        private void ActionButton_Click(object sender, EventArgs e)
        {
            if (!(sender is Button btn) || !(btn.Tag is ActionButtonDefinition actionDef)) return;

            var currentView = _bindingSource.Current as DataRowView;
            if (actionDef.RequiresSelection && currentView == null)
            {
                MessageBox.Show("Please select a record before performing this action.", "Selection Required", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            if (_globalConfig.DisableCustomActionExecution)
            {
                MessageBox.Show("Execution of custom actions is disabled by configuration.", "Action Disabled", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                FileLogger.Warning($"Execution of ActionButton '{actionDef.Name}' blocked by DisableCustomActionExecution=True.");
                return;
            }

            try
            {
                string command = actionDef.Command;
                var rowData = currentView?.Row.Table.Columns.Cast<DataColumn>()
                                     .ToDictionary(col => col.ColumnName, col => currentView[col.ColumnName], StringComparer.OrdinalIgnoreCase)
                                     ?? new Dictionary<string, object>();

                command = Regex.Replace(command, @"\{(\w+)\}", match => {
                    string columnName = match.Groups[1].Value;
                    if (rowData.TryGetValue(columnName, out object value) && value != DBNull.Value && value != null)
                    {
                        string stringValue = value.ToString();
                        return stringValue.Contains(" ") ? $"\"{stringValue}\"" : stringValue;
                    }
                    return string.Empty;
                });

                OnStatusChanged($"Executing action: {actionDef.Label}...");
                ProcessStartInfo startInfo = new ProcessStartInfo
                {
                    FileName = command.Split(' ')[0],
                    Arguments = command.Contains(" ") ? command.Substring(command.IndexOf(' ') + 1) : "",
                    UseShellExecute = true
                };

                using (Process process = Process.Start(startInfo))
                {
                    if (!string.IsNullOrEmpty(actionDef.SuccessMessage))
                    {
                        MessageBox.Show(actionDef.SuccessMessage, "Action Started", MessageBoxButtons.OK, MessageBoxIcon.Information);
                    }
                    OnStatusChanged($"Action '{actionDef.Label}' executed. Ready. - {TableSchema.DisplayName}");
                }
            }
            catch (Exception ex)
            {
                HandleError($"Error executing action '{actionDef.Label}'", ex);
                OnStatusChanged($"Error executing action '{actionDef.Label}'. Ready. - {TableSchema.DisplayName}");
            }
        }


        private bool PromptSaveChanges()
        {
            if (!IsDirty) return true;

            var result = MessageBox.Show($"Save changes to the current record in '{TableSchema.DisplayName}'?",
                                         "Unsaved Changes", MessageBoxButtons.YesNoCancel, MessageBoxIcon.Warning);

            if (result == DialogResult.Yes)
            {
                Task<bool> saveTask = Task.Run(async () => { await SaveButton_ClickAsync(); return !IsDirty; });
                return saveTask.Result;
            }
            else if (result == DialogResult.No)
            {
                IsDirty = false;
                _isNewRecord = false;
                _bindingSource.ResumeBinding();
                PopulateDetailPanel(); // Calls instance method on _detailBuilder
                SetEditMode(false);
                return true;
            }
            else
            {
                return false;
            }
        }

        private void DataViewForm_FormClosing(object sender, FormClosingEventArgs e)
        {
            if (!PromptSaveChanges())
            {
                e.Cancel = true;
            }
        }

        private void UpdateTitle()
        {
            string baseTitle = TableSchema.DisplayName;
            this.Text = IsDirty ? baseTitle + " " + Constants.DirtyFlagIndicator : baseTitle;
            if (_isNewRecord) this.Text += " (New)";
        }

        private void HandleError(string message, Exception ex)
        {
            FileLogger.Error(message, ex);
            MessageBox.Show($"{message}:\n{ex.Message}\n\nSee log file for details.", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
        }

        private void HandleConcurrencyError(DBConcurrencyException ex)
        {
            FileLogger.Error("Concurrency conflict detected.", ex);
            var result = MessageBox.Show($"{ex.Message}\n\nDo you want to reload the data? Reloading will discard your current changes.",
                                         "Concurrency Conflict", MessageBoxButtons.YesNo, MessageBoxIcon.Warning);
            if (result == DialogResult.Yes)
            {
                IsDirty = false;
                _isNewRecord = false;
                Task.Run(async () => await RefreshDataAsync(true));
            }
        }

        private void MainDataGridView_DataError(object sender, DataGridViewDataErrorEventArgs e)
        {
            FileLogger.Error($"DataGridView Error at ({e.ColumnIndex},{e.RowIndex}): {e.Exception.Message}", e.Exception);
            OnStatusChanged($"Display Error: {e.Exception.Message}");
            e.ThrowException = false;
        }

        protected virtual void OnStatusChanged(string message)
        {
            StatusChanged?.Invoke(this, message);
        }

        public bool SaveChanges()
        {
            if (!IsDirty) return true;
            Task<bool> saveTask = Task.Run(async () => { await SaveButton_ClickAsync(); return !IsDirty; });
            return saveTask.Result;
        }
    }
}

---
.\UI\MainForm.Designer.cs
---
namespace DynamicSqlEditor.UI
{
    partial class MainForm
    {
        private System.ComponentModel.IContainer components = null;
        private System.Windows.Forms.MenuStrip menuStrip;
        private System.Windows.Forms.StatusStrip statusStrip;
        private System.Windows.Forms.ToolStripStatusLabel toolStripStatusLabel;
        private System.Windows.Forms.ToolStripMenuItem fileToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem exitToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem tablesToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem windowToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem cascadeToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem tileHorizontalToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem tileVerticalToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem closeAllToolStripMenuItem;

        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        private void InitializeComponent()
        {
            this.menuStrip = new System.Windows.Forms.MenuStrip();
            this.fileToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.exitToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.tablesToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.windowToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.cascadeToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.tileHorizontalToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.tileVerticalToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.closeAllToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.statusStrip = new System.Windows.Forms.StatusStrip();
            this.toolStripStatusLabel = new System.Windows.Forms.ToolStripStatusLabel();
            this.menuStrip.SuspendLayout();
            this.statusStrip.SuspendLayout();
            this.SuspendLayout();
            //
            // menuStrip
            //
            this.menuStrip.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.fileToolStripMenuItem,
            this.tablesToolStripMenuItem,
            this.windowToolStripMenuItem});
            this.menuStrip.Location = new System.Drawing.Point(0, 0);
            this.menuStrip.MdiWindowListItem = this.windowToolStripMenuItem;
            this.menuStrip.Name = "menuStrip";
            this.menuStrip.Size = new System.Drawing.Size(800, 24);
            this.menuStrip.TabIndex = 0;
            this.menuStrip.Text = "menuStrip1";
            //
            // fileToolStripMenuItem
            //
            this.fileToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.exitToolStripMenuItem});
            this.fileToolStripMenuItem.Name = "fileToolStripMenuItem";
            this.fileToolStripMenuItem.Size = new System.Drawing.Size(37, 20);
            this.fileToolStripMenuItem.Text = "&File";
            //
            // exitToolStripMenuItem
            //
            this.exitToolStripMenuItem.Name = "exitToolStripMenuItem";
            this.exitToolStripMenuItem.Size = new System.Drawing.Size(93, 22);
            this.exitToolStripMenuItem.Text = "E&xit";
            this.exitToolStripMenuItem.Click += new System.EventHandler(this.exitToolStripMenuItem_Click);
            //
            // tablesToolStripMenuItem
            //
            this.tablesToolStripMenuItem.Enabled = false;
            this.tablesToolStripMenuItem.Name = "tablesToolStripMenuItem";
            this.tablesToolStripMenuItem.Size = new System.Drawing.Size(52, 20);
            this.tablesToolStripMenuItem.Text = "&Tables";
            //
            // windowToolStripMenuItem
            //
            this.windowToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.cascadeToolStripMenuItem,
            this.tileHorizontalToolStripMenuItem,
            this.tileVerticalToolStripMenuItem,
            this.closeAllToolStripMenuItem});
            this.windowToolStripMenuItem.Name = "windowToolStripMenuItem";
            this.windowToolStripMenuItem.Size = new System.Drawing.Size(63, 20);
            this.windowToolStripMenuItem.Text = "&Window";
            //
            // cascadeToolStripMenuItem
            //
            this.cascadeToolStripMenuItem.Name = "cascadeToolStripMenuItem";
            this.cascadeToolStripMenuItem.Size = new System.Drawing.Size(150, 22);
            this.cascadeToolStripMenuItem.Text = "&Cascade";
            this.cascadeToolStripMenuItem.Click += new System.EventHandler(this.cascadeToolStripMenuItem_Click);
            //
            // tileHorizontalToolStripMenuItem
            //
            this.tileHorizontalToolStripMenuItem.Name = "tileHorizontalToolStripMenuItem";
            this.tileHorizontalToolStripMenuItem.Size = new System.Drawing.Size(150, 22);
            this.tileHorizontalToolStripMenuItem.Text = "Tile &Horizontal";
            this.tileHorizontalToolStripMenuItem.Click += new System.EventHandler(this.tileHorizontalToolStripMenuItem_Click);
            //
            // tileVerticalToolStripMenuItem
            //
            this.tileVerticalToolStripMenuItem.Name = "tileVerticalToolStripMenuItem";
            this.tileVerticalToolStripMenuItem.Size = new System.Drawing.Size(150, 22);
            this.tileVerticalToolStripMenuItem.Text = "Tile &Vertical";
            this.tileVerticalToolStripMenuItem.Click += new System.EventHandler(this.tileVerticalToolStripMenuItem_Click);
            //
            // closeAllToolStripMenuItem
            //
            this.closeAllToolStripMenuItem.Name = "closeAllToolStripMenuItem";
            this.closeAllToolStripMenuItem.Size = new System.Drawing.Size(150, 22);
            this.closeAllToolStripMenuItem.Text = "Close &All";
            this.closeAllToolStripMenuItem.Click += new System.EventHandler(this.closeAllToolStripMenuItem_Click);
            //
            // statusStrip
            //
            this.statusStrip.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.toolStripStatusLabel});
            this.statusStrip.Location = new System.Drawing.Point(0, 428);
            this.statusStrip.Name = "statusStrip";
            this.statusStrip.Size = new System.Drawing.Size(800, 22);
            this.statusStrip.TabIndex = 1;
            this.statusStrip.Text = "statusStrip1";
            //
            // toolStripStatusLabel
            //
            this.toolStripStatusLabel.Name = "toolStripStatusLabel";
            this.toolStripStatusLabel.Size = new System.Drawing.Size(39, 17);
            this.toolStripStatusLabel.Text = "Ready";
            //
            // MainForm
            //
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(800, 450);
            this.Controls.Add(this.statusStrip);
            this.Controls.Add(this.menuStrip);
            this.IsMdiContainer = true;
            this.MainMenuStrip = this.menuStrip;
            this.Name = "MainForm";
            this.Text = "Dynamic SQL Editor";
            this.menuStrip.ResumeLayout(false);
            this.menuStrip.PerformLayout();
            this.statusStrip.ResumeLayout(false);
            this.statusStrip.PerformLayout();
            this.ResumeLayout(false);
            this.PerformLayout();

        }
    }
}

---
.\UI\MainForm.cs
---
using System;
using System.Linq;
using System.Windows.Forms;
using DynamicSqlEditor.Common;
using DynamicSqlEditor.Core;
using DynamicSqlEditor.Schema.Models;

namespace DynamicSqlEditor.UI
{
    public partial class MainForm : Form
    {
        private readonly StateManager _stateManager;

        public MainForm()
        {
            InitializeComponent();
            _stateManager = new StateManager();
            _stateManager.ConnectionChanged += StateManager_ConnectionChanged;
            _stateManager.SchemaRefreshed += StateManager_SchemaRefreshed;

            this.Load += MainForm_Load;
        }

        private void MainForm_Load(object sender, EventArgs e)
        {
            this.WindowState = FormWindowState.Maximized;
            UpdateStatus("Initializing...");
            if (_stateManager.Initialize())
            {
                 UpdateStatus($"Connected to {_stateManager.CurrentDatabaseName}. Ready.");
            }
            else
            {
                 UpdateStatus("Connection failed. Please check configuration or logs.");
                 MessageBox.Show("Failed to connect to the database based on configuration. Please check AppConfig.dsl and logs.", "Connection Error", MessageBoxButtons.OK, MessageBoxIcon.Warning);
            }
        }

        private void StateManager_ConnectionChanged(object sender, EventArgs e)
        {
            if (this.InvokeRequired)
            {
                this.Invoke(new Action(() => StateManager_ConnectionChanged(sender, e)));
                return;
            }

            if (_stateManager.IsConnected)
            {
                UpdateStatus($"Connected to {_stateManager.CurrentDatabaseName}. Refreshing schema...");
                // Schema refresh will be triggered by Initialize or explicit call
            }
            else
            {
                UpdateStatus("Disconnected.");
                ClearTableMenu();
            }
        }

        private void StateManager_SchemaRefreshed(object sender, EventArgs e)
        {
             if (this.InvokeRequired)
            {
                this.Invoke(new Action(() => StateManager_SchemaRefreshed(sender, e)));
                return;
            }
            PopulateTableMenu();
             if (_stateManager.IsConnected) UpdateStatus($"Connected to {_stateManager.CurrentDatabaseName}. Ready.");
        }

        private void PopulateTableMenu()
        {
            ClearTableMenu();

            if (_stateManager.AvailableTables == null || !_stateManager.AvailableTables.Any())
            {
                tablesToolStripMenuItem.Enabled = false;
                return;
            }

            tablesToolStripMenuItem.Enabled = true;
            var groupedTables = _stateManager.AvailableTables
                                             .OrderBy(t => t.SchemaName)
                                             .ThenBy(t => t.TableName)
                                             .GroupBy(t => t.SchemaName);

            foreach (var group in groupedTables)
            {
                ToolStripMenuItem schemaMenuItem;
                if (groupedTables.Count() > 1 || !string.Equals(group.Key, "dbo", StringComparison.OrdinalIgnoreCase))
                {
                    schemaMenuItem = new ToolStripMenuItem(group.Key);
                    tablesToolStripMenuItem.DropDownItems.Add(schemaMenuItem);
                }
                else
                {
                    // Add directly to main menu if only one schema (or only dbo)
                    schemaMenuItem = tablesToolStripMenuItem;
                }

                foreach (var table in group)
                {
                    var tableMenuItem = new ToolStripMenuItem(table.TableName) { Tag = table };
                    tableMenuItem.Click += TableMenuItem_Click;
                    schemaMenuItem.DropDownItems.Add(tableMenuItem);
                }
            }
        }

        private void ClearTableMenu()
        {
             // Remove all except potentially placeholder items if needed
             tablesToolStripMenuItem.DropDownItems.Clear();
        }


        private void TableMenuItem_Click(object sender, EventArgs e)
        {
            if (sender is ToolStripMenuItem menuItem && menuItem.Tag is TableSchema tableSchema)
            {
                OpenDataViewForm(tableSchema);
            }
        }

        private void OpenDataViewForm(TableSchema tableSchema)
        {
            // Check if already open
            foreach (Form form in this.MdiChildren)
            {
                if (form is DataViewForm dvf && dvf.TableSchema.FullName == tableSchema.FullName)
                {
                    dvf.Activate();
                    return;
                }
            }

            try
            {
                UpdateStatus($"Loading view for {tableSchema.DisplayName}...");
                var dataViewForm = new DataViewForm(_stateManager, tableSchema);
                dataViewForm.MdiParent = this;
                dataViewForm.StatusChanged += ChildForm_StatusChanged;
                dataViewForm.Show();
                // Status update will happen within DataViewForm Load/Async operations
            }
            catch (Exception ex)
            {
                 string errorMsg = $"Error opening view for {tableSchema.DisplayName}: {ex.Message}";
                 FileLogger.Error(errorMsg, ex);
                 MessageBox.Show(errorMsg, "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                 UpdateStatus($"Error loading {tableSchema.DisplayName}. Ready.");
            }
        }

         private void ChildForm_StatusChanged(object sender, string statusMessage)
        {
            UpdateStatus(statusMessage);
        }

        private void UpdateStatus(string message)
        {
            if (statusStrip.InvokeRequired)
            {
                statusStrip.Invoke(new Action(() => UpdateStatus(message)));
                return;
            }
            toolStripStatusLabel.Text = message;
        }


        private void exitToolStripMenuItem_Click(object sender, EventArgs e)
        {
            Application.Exit();
        }

        private void cascadeToolStripMenuItem_Click(object sender, EventArgs e)
        {
            this.LayoutMdi(MdiLayout.Cascade);
        }

        private void tileHorizontalToolStripMenuItem_Click(object sender, EventArgs e)
        {
            this.LayoutMdi(MdiLayout.TileHorizontal);
        }

        private void tileVerticalToolStripMenuItem_Click(object sender, EventArgs e)
        {
            this.LayoutMdi(MdiLayout.TileVertical);
        }

        private void closeAllToolStripMenuItem_Click(object sender, EventArgs e)
        {
             // Use a copy of the collection to avoid issues while closing
            var children = this.MdiChildren.ToList();
            foreach (Form child in children)
            {
                child.Close();
                 // Check if close was cancelled (e.g., by unsaved changes prompt)
                if (child.Visible)
                {
                    // Optional: Stop closing others if one fails?
                    // break;
                }
            }
        }

        protected override void OnFormClosing(FormClosingEventArgs e)
        {
             // Check for unsaved changes in children before closing main form
             foreach (Form child in this.MdiChildren)
             {
                 if (child is DataViewForm dvf && dvf.IsDirty)
                 {
                     var result = MessageBox.Show($"Form '{dvf.Text.TrimEnd('*')}' has unsaved changes. Save before closing application?",
                                                  "Unsaved Changes", MessageBoxButtons.YesNoCancel, MessageBoxIcon.Warning);
                     if (result == DialogResult.Yes)
                     {
                         if (!dvf.SaveChanges()) // Attempt save
                         {
                             e.Cancel = true; // Cancel closing if save fails
                             return;
                         }
                     }
                     else if (result == DialogResult.Cancel)
                     {
                         e.Cancel = true; // Cancel closing application
                         return;
                     }
                     // If No, continue closing without saving this child
                 }
             }

            base.OnFormClosing(e);
        }
    }
}

---
.\UI\Builders\ActionButtonBuilder.cs
---
using System;
using System.Drawing;
using System.Linq;
using System.Windows.Forms;
using DynamicSqlEditor.Configuration.Models;

namespace DynamicSqlEditor.UI.Builders
{
    public class ActionButtonBuilder
    {
        private readonly Panel _actionButtonPanel;
        private readonly TableConfig _tableConfig;
        private readonly GlobalConfig _globalConfig;

        public ActionButtonBuilder(Panel actionButtonPanel, TableConfig tableConfig, GlobalConfig globalConfig)
        {
            _actionButtonPanel = actionButtonPanel ?? throw new ArgumentNullException(nameof(actionButtonPanel));
            _tableConfig = tableConfig ?? throw new ArgumentNullException(nameof(tableConfig));
            _globalConfig = globalConfig ?? throw new ArgumentNullException(nameof(globalConfig));
        }

        public void BuildButtons(EventHandler buttonClickHandler)
        {
            _actionButtonPanel.Controls.Clear();
            _actionButtonPanel.Visible = _tableConfig.ActionButtons.Any();

            if (!_actionButtonPanel.Visible) return;

            var flowPanel = new FlowLayoutPanel
            {
                Dock = DockStyle.Fill,
                FlowDirection = FlowDirection.LeftToRight,
                WrapContents = false, // Keep buttons on one line if possible
                AutoScroll = true // Add scroll if they don't fit
            };

            foreach (var kvp in _tableConfig.ActionButtons.OrderBy(b => b.Value.Label)) // Order alphabetically
            {
                var actionDef = kvp.Value;
                var button = new Button
                {
                    Text = actionDef.Label,
                    Tag = actionDef, // Store definition for click handler
                    AutoSize = true,
                    MinimumSize = new Size(80, 0), // Minimum width
                    Margin = new Padding(3),
                    Enabled = !actionDef.RequiresSelection // Initially enabled only if selection not required
                };

                // Check if execution is globally disabled
                if (_globalConfig.DisableCustomActionExecution)
                {
                    button.Enabled = false;
                    button.Text += " (Disabled)";
                    // Optionally add a tooltip explaining why it's disabled
                    var toolTip = new ToolTip();
                    toolTip.SetToolTip(button, "Custom action execution is disabled in configuration.");
                }
                else
                {
                    button.Click += buttonClickHandler;
                }

                flowPanel.Controls.Add(button);
            }

            _actionButtonPanel.Controls.Add(flowPanel);
        }
    }
}

---
.\UI\Builders\DetailFormBuilder.cs
---
// File: DynamicSqlEditor/UI/Builders/DetailFormBuilder.cs
using System;
using System.Collections.Generic;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Forms;
using DynamicSqlEditor.Common;
using DynamicSqlEditor.Configuration.Models;
using DynamicSqlEditor.Core;
using DynamicSqlEditor.Schema.Models;
using DynamicSqlEditor.UI.Controls;

namespace DynamicSqlEditor.UI.Builders
{
    public class DetailFormBuilder
    {
        private readonly Panel _detailPanel;
        private readonly TableSchema _tableSchema;
        private readonly TableConfig _tableConfig;
        private readonly GlobalConfig _globalConfig;
        private readonly StateManager _stateManager;
        private readonly DynamicSqlEditor.Core.DataViewManager _dataViewManager;

        public DetailFormBuilder(Panel detailPanel, TableSchema tableSchema, TableConfig tableConfig, GlobalConfig globalConfig, StateManager stateManager, DynamicSqlEditor.Core.DataViewManager dataViewManager)
        {
            _detailPanel = detailPanel ?? throw new ArgumentNullException(nameof(detailPanel));
            _tableSchema = tableSchema ?? throw new ArgumentNullException(nameof(tableSchema));
            _tableConfig = tableConfig ?? throw new ArgumentNullException(nameof(tableConfig));
            _globalConfig = globalConfig ?? throw new ArgumentNullException(nameof(globalConfig));
            _stateManager = stateManager ?? throw new ArgumentNullException(nameof(stateManager));
            _dataViewManager = dataViewManager ?? throw new ArgumentNullException(nameof(dataViewManager));
        }

        // Instance method now
        public async Task BuildFormAsync(EventHandler valueChangedHandler)
        {
            _detailPanel.Controls.Clear();
            var tableLayout = new TableLayoutPanel
            {
                Dock = DockStyle.Top,
                AutoSize = true,
                ColumnCount = 3, // Label, Control, IsNull CheckBox
                Padding = new Padding(10)
            };
            tableLayout.ColumnStyles.Add(new ColumnStyle(SizeType.AutoSize)); // Label
            tableLayout.ColumnStyles.Add(new ColumnStyle(SizeType.Percent, 100F)); // Control (takes remaining space)
            tableLayout.ColumnStyles.Add(new ColumnStyle(SizeType.AutoSize)); // IsNull CheckBox

            var fieldsToDisplay = GetFieldsToDisplay(); // Instance method call

            foreach (var fieldInfo in fieldsToDisplay)
            {
                var column = fieldInfo.Column;
                var fieldConfig = fieldInfo.Config;

                Label label = ControlFactory.CreateLabel(column, fieldConfig);
                Control control = ControlFactory.CreateControl(column, fieldConfig);
                CheckBox isNullCheckBox = ControlFactory.CreateIsNullCheckBox(column);

                control.Name = column.ColumnName; // Set control name for easy lookup
                control.Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right; // Allow horizontal stretching
                control.Margin = new Padding(3);
                label.Margin = new Padding(3, 6, 3, 3); // Align label vertically with control center

                // Configure ComboBox for FKs
                if (control is ComboBox comboBox)
                {
                    ConfigureForeignKeyComboBox(comboBox, column.ColumnName); // Instance method call
                }

                // Wire up ValueChanged event
                if (control is TextBoxBase txt) txt.TextChanged += valueChangedHandler;
                else if (control is CheckBox chk && chk != isNullCheckBox) chk.CheckedChanged += valueChangedHandler;
                else if (control is DateTimePicker dtp) dtp.ValueChanged += valueChangedHandler;
                else if (control is ComboBox cmb) cmb.SelectedIndexChanged += valueChangedHandler;
                else if (control is NullableDateTimePicker ndtp) ndtp.ValueChanged += valueChangedHandler;

                // Wire up IsNull checkbox event
                if (isNullCheckBox != null)
                {
                    isNullCheckBox.Name = $"IsNullChk_{column.ColumnName}";
                    isNullCheckBox.Margin = new Padding(3, 6, 3, 3);
                    isNullCheckBox.CheckedChanged += valueChangedHandler; // Track changes on this too
                }

                // Add to layout panel
                tableLayout.RowCount++;
                tableLayout.RowStyles.Add(new RowStyle(SizeType.AutoSize));
                tableLayout.Controls.Add(label, 0, tableLayout.RowCount - 1);
                tableLayout.Controls.Add(control, 1, tableLayout.RowCount - 1);
                if (isNullCheckBox != null)
                {
                    tableLayout.Controls.Add(isNullCheckBox, 2, tableLayout.RowCount - 1);
                }
            }

            _detailPanel.Controls.Add(tableLayout);
            await Task.CompletedTask;
        }

        // Instance method
        private List<(ColumnSchema Column, DetailFormFieldDefinition Config)> GetFieldsToDisplay()
        {
            var displayList = new List<(ColumnSchema Column, DetailFormFieldDefinition Config)>();

            // Start with columns from schema
            foreach (var col in this._tableSchema.Columns.OrderBy(c => c.OrdinalPosition)) // Use instance field
            {
                this._tableConfig.DetailFormFields.TryGetValue(col.ColumnName, out var fieldConfig); // Use instance field

                // Determine visibility
                bool isVisibleByDefault = !col.IsTimestamp && !IsComplexType(col.DataType);
                bool isVisible = fieldConfig?.Visible ?? isVisibleByDefault;

                if (isVisible)
                {
                    // Use config order if specified, otherwise use schema order
                    int order = fieldConfig?.Order ?? col.OrdinalPosition + 1000; // Add offset to prioritize configured order
                    displayList.Add((col, fieldConfig ?? new DetailFormFieldDefinition { ColumnName = col.ColumnName, Order = order }));
                }
            }

            // Sort based on final Order value
            return displayList.OrderBy(item => item.Config.Order).ToList();
        }

        // Instance method
        private void ConfigureForeignKeyComboBox(ComboBox comboBox, string fkColumnName)
        {
            FKLookupDefinition lookupConfig = null;

            // 1. Check explicit FKLookup config
            if (this._tableConfig.FKLookups.TryGetValue(fkColumnName, out var explicitConfig)) // Use instance field
            {
                lookupConfig = explicitConfig;
            }
            else
            {
                // 2. Check discovered FK constraints
                var discoveredFk = this._tableSchema.GetForeignKey(fkColumnName); // Use instance field
                if (discoveredFk != null)
                {
                    // 3. Use FK Heuristics to find display column
                    string displayColumn = FindBestDisplayColumn(discoveredFk.ReferencedTable); // Instance method call
                    if (displayColumn != null)
                    {
                        lookupConfig = new FKLookupDefinition
                        {
                            FKColumnName = fkColumnName,
                            ReferencedTable = discoveredFk.ReferencedTable.FullName.Replace("[", "").Replace("]", ""), // Use Schema.Table format
                            DisplayColumn = displayColumn,
                            ValueColumn = discoveredFk.ReferencedColumn.ColumnName // Use the actual referenced column
                            // ReferencedColumn defaults correctly here
                        };
                    }
                    else
                    {
                        FileLogger.Warning($"Could not determine display column using heuristics for FK '{fkColumnName}' referencing '{discoveredFk.ReferencedTable.DisplayName}'. ComboBox will not be populated.");
                        comboBox.Enabled = false; // Disable if lookup cannot be configured
                        comboBox.Items.Add("Lookup Error");
                        return;
                    }
                }
            }

            if (lookupConfig == null)
            {
                // If ControlType=ComboBox was forced but no FK found/configured
                FileLogger.Warning($"Control for '{fkColumnName}' is ComboBox, but no FKLookup configuration or discoverable FK relationship found.");
                comboBox.Enabled = false;
                comboBox.Items.Add("Config Error");
                return;
            }

            // Populate ComboBox - Keep this part async as it involves DB access via DataViewManager
            // Use an async void lambda or a separate async helper method to load data after setup
            LoadComboBoxDataAsync(comboBox, lookupConfig, fkColumnName); // Instance method call
        }

        // Instance method
        private async void LoadComboBoxDataAsync(ComboBox comboBox, FKLookupDefinition lookupConfig, string fkColumnName)
        {
            try
            {
                comboBox.Enabled = false; // Disable while loading
                comboBox.DataSource = null; // Clear previous
                comboBox.Items.Clear();
                comboBox.Items.Add("Loading...");
                comboBox.SelectedIndex = 0;

                DataTable lookupData = await this._dataViewManager.GetLookupDataAsync(lookupConfig); // Use instance field

                // Determine ValueMember using the now synchronous helper
                string valueMember = lookupConfig.ValueColumn ?? GetPrimaryKeyColumnName(lookupConfig.ReferencedTable); // Instance method call
                if (string.IsNullOrEmpty(valueMember))
                {
                    throw new InvalidOperationException($"Could not determine ValueMember for ComboBox '{fkColumnName}'.");
                }

                comboBox.DataSource = lookupData;
                comboBox.DisplayMember = lookupConfig.DisplayColumn;
                comboBox.ValueMember = valueMember;
                comboBox.SelectedIndex = -1; // Start with no selection
                comboBox.Enabled = true; // Re-enable after loading
            }
            catch (Exception ex)
            {
                FileLogger.Error($"Failed to populate ComboBox for FK '{fkColumnName}' using lookup '{lookupConfig.ReferencedTable}'.", ex);
                comboBox.DataSource = null;
                comboBox.Items.Clear();
                comboBox.Items.Add("Data Load Error");
                comboBox.Enabled = false; // Keep disabled on error
            }
        }

        // Instance method
        private string FindBestDisplayColumn(TableSchema referencedTable)
        {
            // Use the _globalConfig field here
            var heuristicOrder = this._globalConfig.DefaultFKDisplayHeuristic; // Use instance field

            foreach (string heuristic in heuristicOrder)
            {
                if (heuristic.Contains("*")) // Wildcard match (e.g., *ID)
                {
                    // Ensure pattern is valid regex (escape special chars if needed, but * is handled)
                    string pattern = heuristic.Replace(".", @"\.").Replace("*", ".*"); // Escape dots, convert *
                    try
                    {
                        var match = referencedTable.Columns.FirstOrDefault(c => System.Text.RegularExpressions.Regex.IsMatch(c.ColumnName, $"^{pattern}$", System.Text.RegularExpressions.RegexOptions.IgnoreCase));
                        if (match != null) return match.ColumnName;
                    }
                    catch (ArgumentException regexEx)
                    {
                        FileLogger.Warning($"Invalid regex pattern generated from heuristic '{heuristic}': {regexEx.Message}");
                        // Continue to next heuristic
                    }
                }
                else // Exact match
                {
                    var match = referencedTable.Columns.FirstOrDefault(c => c.ColumnName.Equals(heuristic, StringComparison.OrdinalIgnoreCase));
                    if (match != null) return match.ColumnName;
                }
            }

            // Fallback: Use the first string column? Or the PK itself?
            // Let's try first string column
            var firstStringCol = referencedTable.Columns.FirstOrDefault(c => c.DataType.ToLower().Contains("char") || c.DataType.ToLower().Contains("text"));
            if (firstStringCol != null)
            {
                FileLogger.Info($"FK heuristic fallback: Using first string column '{firstStringCol.ColumnName}' for table '{referencedTable.DisplayName}'.");
                return firstStringCol.ColumnName;
            }

            // Final fallback: use PK if single PK
            if (referencedTable.PrimaryKeys.Count == 1)
            {
                FileLogger.Info($"FK heuristic fallback: Using single primary key column '{referencedTable.PrimaryKeys[0].Column.ColumnName}' for table '{referencedTable.DisplayName}'.");
                return referencedTable.PrimaryKeys[0].Column.ColumnName;
            }


            FileLogger.Warning($"FK heuristic failed for table '{referencedTable.DisplayName}'. No suitable display column found.");
            return null; // Return null if no heuristic matches and fallbacks fail
        }

        // Instance method
        private string GetPrimaryKeyColumnName(string fullTableName)
        {
            try
            {
                // Parse Schema.Table format
                string schema = null;
                string table = fullTableName;
                if (fullTableName.Contains("."))
                {
                    var parts = fullTableName.Split('.');
                    schema = parts[0].Trim('[', ']');
                    table = parts[1].Trim('[', ']');
                }
                else // Handle table name without schema (assume default like dbo)
                {
                    schema = "dbo"; // Or get default schema if possible
                }


                // Find the TableSchema in the StateManager's loaded list
                var referencedTableSchema = this._stateManager.AvailableTables.FirstOrDefault(t => // Use instance field
                    t.TableName.Equals(table, StringComparison.OrdinalIgnoreCase) &&
                    t.SchemaName.Equals(schema, StringComparison.OrdinalIgnoreCase)); // Ensure schema matches

                if (referencedTableSchema == null)
                {
                    FileLogger.Error($"Could not find schema information for referenced table '{fullTableName}' in StateManager.");
                    return null;
                }

                // Check if there's exactly one primary key
                if (referencedTableSchema.PrimaryKeys.Count == 1)
                {
                    return referencedTableSchema.PrimaryKeys[0].Column.ColumnName;
                }
                else if (referencedTableSchema.PrimaryKeys.Count == 0)
                {
                    FileLogger.Warning($"Referenced table '{fullTableName}' has no primary key defined in schema.");
                    return null;
                }
                else // Composite key
                {
                    FileLogger.Warning($"Referenced table '{fullTableName}' has a composite primary key. Cannot automatically determine ValueMember for ComboBox. Specify 'ValueColumn' in FKLookup config.");
                    return null;
                }
            }
            catch (Exception ex)
            {
                FileLogger.Error($"Error getting primary key for table {fullTableName} from schema cache", ex);
                return null;
            }
        }

        // Instance method - removed 'static' and 'Panel panel' parameter
        public void PopulateControls(DataRowView rowView)
        {
            if (rowView == null)
            {
                ClearControls(); // Call instance method
                return;
            }

            foreach (Control control in GetAllControlsRecursive(this._detailPanel)) // Use instance field
            {
                string columnName = control.Name;
                if (string.IsNullOrEmpty(columnName) || !rowView.Row.Table.Columns.Contains(columnName))
                {
                    // Handle IsNull checkbox separately
                    if (control is CheckBox isNullChk && isNullChk.Tag?.ToString() == "IsNullCheckBox")
                    {
                        string relatedColumnName = isNullChk.Name.Replace("IsNullChk_", "");
                        if (rowView.Row.Table.Columns.Contains(relatedColumnName))
                        {
                            isNullChk.Checked = rowView[relatedColumnName] == DBNull.Value;
                            var relatedControl = this._detailPanel.Controls.Find(relatedColumnName, true).FirstOrDefault(); // Use instance field
                            if (relatedControl != null) relatedControl.Enabled = !isNullChk.Checked;
                        }
                    }
                    continue;
                }

                object value = rowView[columnName];
                var columnSchema = this._tableSchema.GetColumn(columnName); // Use instance field
                this._tableConfig.DetailFormFields.TryGetValue(columnName, out var fieldConfig); // Use instance field
                bool isReadOnly = IsControlReadOnly(columnSchema, fieldConfig); // Call instance method overload

                try
                {
                    if (control is TextBoxBase txt)
                    {
                        txt.Text = value == DBNull.Value ? string.Empty : value.ToString();
                        txt.ReadOnly = isReadOnly; // Use calculated value
                    }
                    else if (control is CheckBox chk && chk.Tag?.ToString() != "IsNullCheckBox")
                    {
                        chk.Checked = value != DBNull.Value && Convert.ToBoolean(value);
                        chk.Enabled = !isReadOnly; // Use calculated value
                    }
                    else if (control is DateTimePicker dtp)
                    {
                        if (value != DBNull.Value) dtp.Value = Convert.ToDateTime(value);
                        // Handle null for standard picker? Maybe disable if null? Or rely on IsNullChk
                        dtp.Enabled = !isReadOnly; // Use calculated value
                    }
                    else if (control is NullableDateTimePicker ndtp)
                    {
                        ndtp.Value = (value == DBNull.Value) ? (DateTime?)null : Convert.ToDateTime(value);
                        ndtp.Enabled = !isReadOnly; // Use calculated value
                    }
                    else if (control is ComboBox cmb)
                    {
                        try
                        {
                            if (cmb.DataSource != null || cmb.Items.Count > 0) cmb.SelectedValue = value ?? DBNull.Value;
                            else FileLogger.Info($"ComboBox '{cmb.Name}' data source not ready when trying to set value '{value}'.");
                        }
                        catch (Exception svEx)
                        {
                            FileLogger.Warning($"Error setting SelectedValue for ComboBox '{cmb.Name}' to '{value}': {svEx.Message}");
                            cmb.SelectedIndex = -1;
                        }
                        cmb.Enabled = !isReadOnly; // Use calculated value
                    }
                    else if (control is Label lbl)
                    {
                        lbl.Text = value == DBNull.Value ? string.Empty : FormatDisplayValue(value);
                    }
                }
                catch (Exception ex)
                {
                    FileLogger.Warning($"Error populating control '{control.Name}' for column '{columnName}': {ex.Message}");
                }
            }
        }

        // Instance method - removed 'static' and 'Panel panel' parameter
        public void ClearControls()
        {
            foreach (Control control in GetAllControlsRecursive(this._detailPanel)) // Use instance field
            {
                if (control is TextBoxBase txt) txt.Clear();
                else if (control is CheckBox chk && chk.Tag?.ToString() != "IsNullCheckBox") chk.Checked = false;
                else if (control is DateTimePicker dtp) dtp.Value = DateTime.Now;
                else if (control is NullableDateTimePicker ndtp) ndtp.Value = null;
                else if (control is ComboBox cmb) cmb.SelectedIndex = -1;
                else if (control is Label lbl && !lbl.Text.EndsWith(":")) lbl.Text = string.Empty;

                if (control is CheckBox isNullChk && isNullChk.Tag?.ToString() == "IsNullCheckBox")
                {
                    isNullChk.Checked = false;
                    var relatedControl = this._detailPanel.Controls.Find(isNullChk.Name.Replace("IsNullChk_", ""), true).FirstOrDefault(); // Use instance field
                    if (relatedControl != null) relatedControl.Enabled = true; // Re-enable related control
                }
            }
        }

        // Instance method - removed 'static' and 'Panel panel' parameter
        public Dictionary<string, object> GetControlValues()
        {
            var values = new Dictionary<string, object>(StringComparer.OrdinalIgnoreCase);
            foreach (Control control in GetAllControlsRecursive(this._detailPanel)) // Use instance field
            {
                string columnName = control.Name;
                if (string.IsNullOrEmpty(columnName) || values.ContainsKey(columnName)) continue;

                var isNullChk = this._detailPanel.Controls.Find($"IsNullChk_{columnName}", true).FirstOrDefault() as CheckBox; // Use instance field
                if (isNullChk != null && isNullChk.Checked)
                {
                    values[columnName] = DBNull.Value;
                    continue;
                }

                object value = null;
                if (control is TextBoxBase txt) value = string.IsNullOrEmpty(txt.Text) ? (object)DBNull.Value : txt.Text;
                else if (control is CheckBox chk && chk.Tag?.ToString() != "IsNullCheckBox") value = chk.Checked;
                else if (control is DateTimePicker dtp) value = dtp.Value;
                else if (control is NullableDateTimePicker ndtp) value = ndtp.Value.HasValue ? (object)ndtp.Value.Value : DBNull.Value;
                else if (control is ComboBox cmb) value = cmb.SelectedValue ?? DBNull.Value;

                if (value != null)
                {
                    var columnSchema = this._tableSchema.GetColumn(columnName); // Use instance field
                    if (columnSchema != null && value != DBNull.Value)
                    {
                        try
                        {
                            Type targetType = GetClrType(columnSchema.DataType);
                            if (targetType != null && value.GetType() != targetType)
                            {
                                if (targetType == typeof(Guid) && value is string sGuid && Guid.TryParse(sGuid, out Guid guidResult)) value = guidResult;
                                else if (targetType == typeof(byte[]) && value is string sBytes) value = Convert.FromBase64String(sBytes);
                                else value = Convert.ChangeType(value, targetType);
                            }
                        }
                        catch (Exception convEx) when (convEx is FormatException || convEx is InvalidCastException || convEx is OverflowException)
                        {
                            FileLogger.Warning($"Could not convert value for column '{columnName}' to target type '{columnSchema.DataType}': {convEx.Message}");
                        }
                    }
                    values[columnName] = value;
                }
            }
            return values;
        }

        // Instance method - removed 'static' and 'Panel panel' parameter
        public void SetControlsEnabled(bool enabled)
        {
            foreach (Control control in GetAllControlsRecursive(this._detailPanel)) // Use instance field
            {
                string columnName = control.Name;
                if (string.IsNullOrEmpty(columnName)) continue;

                var columnSchema = this._tableSchema.GetColumn(columnName); // Use instance field
                this._tableConfig.DetailFormFields.TryGetValue(columnName, out var fieldConfig); // Use instance field
                bool isReadOnly = IsControlReadOnly(columnSchema, fieldConfig); // Call instance method overload

                bool shouldBeEnabled = enabled && !isReadOnly;

                // Check if the current control is an IsNull checkbox
                if (control is CheckBox isNullChk && isNullChk.Tag?.ToString() == "IsNullCheckBox") // First declaration of isNullChk
                {
                    var relatedControlName = isNullChk.Name.Replace("IsNullChk_", "");
                    var relatedColumnSchema = this._tableSchema.GetColumn(relatedControlName); // Use instance field
                    this._tableConfig.DetailFormFields.TryGetValue(relatedControlName, out var relatedFieldConfig); // Use instance field
                    bool relatedIsReadOnly = IsControlReadOnly(relatedColumnSchema, relatedFieldConfig); // Call instance method overload

                    isNullChk.Enabled = enabled && !relatedIsReadOnly && (relatedColumnSchema?.IsNullable ?? false);
                }
                // If it's not an IsNull checkbox, handle the main control
                else if (!(control is Label))
                {
                    control.Enabled = shouldBeEnabled;

                    // If disabling, ensure IsNull checkbox doesn't leave main control disabled
                    if (!shouldBeEnabled)
                    {
                        // Find the corresponding IsNull checkbox again
                        // Rename the variable here to avoid conflict
                        var correspondingIsNullChk = this._detailPanel.Controls.Find($"IsNullChk_{columnName}", true).FirstOrDefault() as CheckBox; // Renamed variable
                        if (correspondingIsNullChk != null && correspondingIsNullChk.Checked) // Use renamed variable
                        {
                            // If disabling edit mode while control is nulled, keep it disabled
                            control.Enabled = false;
                        }
                    }
                }
            }
        }

        // Instance method overload (was static before)
        private bool IsControlReadOnly(ColumnSchema column, DetailFormFieldDefinition fieldConfig)
        {
            if (column == null) return true;

            if (fieldConfig?.ReadOnly.HasValue ?? false) return fieldConfig.ReadOnly.Value;

            if (column.IsIdentity || column.IsComputed || column.IsTimestamp || column.IsPrimaryKey) return true;

            return false;
        }

        // REMOVED the static overload: IsControlReadOnly(string columnName, DataRowView rowView, Panel panel)

        // Static helper - OK to keep static as it doesn't depend on instance state
        private static IEnumerable<Control> GetAllControlsRecursive(Control container)
        {
            var controls = container.Controls.Cast<Control>();
            return controls.SelectMany(ctrl => GetAllControlsRecursive(ctrl)).Concat(controls);
        }

        // Instance method (could be static, but consistent)
        private bool IsComplexType(string dataType)
        {
            string lowerType = dataType.ToLower();
            return lowerType == "xml" || lowerType == "geography" || lowerType == "geometry" || lowerType == "hierarchyid";
        }

        // Static helper - OK to keep static
        private static string FormatDisplayValue(object value)
        {
            if (value is DateTime dt) return dt.ToString(Constants.DefaultDateTimeFormat);
            return value.ToString();
        }

        // Static helper - OK to keep static
        private static Type GetClrType(string sqlDataType)
        {
            switch (sqlDataType.ToLower())
            {
                case "bigint": return typeof(long);
                case "binary": case "image": case "rowversion": case "timestamp": case "varbinary": return typeof(byte[]);
                case "bit": return typeof(bool);
                case "char": case "nchar": case "ntext": case "nvarchar": case "text": case "varchar": case "xml": return typeof(string);
                case "date": case "datetime": case "datetime2": case "smalldatetime": return typeof(DateTime);
                case "datetimeoffset": return typeof(DateTimeOffset);
                case "decimal": case "money": case "numeric": case "smallmoney": return typeof(decimal);
                case "float": return typeof(double);
                case "int": return typeof(int);
                case "real": return typeof(float);
                case "smallint": return typeof(short);
                case "time": return typeof(TimeSpan);
                case "tinyint": return typeof(byte);
                case "uniqueidentifier": return typeof(Guid);
                default: return typeof(object);
            }
        }
    }
}

---
.\UI\Builders\FilterUIBuilder.cs
---
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Windows.Forms;
using DynamicSqlEditor.Configuration.Models;

namespace DynamicSqlEditor.UI.Builders
{
    public class FilterUIBuilder
    {
        private readonly Panel _filterPanel;
        private readonly TableConfig _tableConfig;
        public const string ClearFilterText = "-- No Filter --";

        public FilterUIBuilder(Panel filterPanel, TableConfig tableConfig)
        {
            _filterPanel = filterPanel ?? throw new ArgumentNullException(nameof(filterPanel));
            _tableConfig = tableConfig ?? throw new ArgumentNullException(nameof(tableConfig));
        }

        public void BuildFilters(EventHandler filterChangedHandler)
        {
            _filterPanel.Controls.Clear();

            if (_tableConfig.Filters == null || !_tableConfig.Filters.Any())
            {
                // Optionally add a label indicating no filters are defined
                return;
            }

            var filterLabel = new Label
            {
                Text = "Filter:",
                AutoSize = true,
                Location = new Point(5, 9), // Adjust position as needed
                Anchor = AnchorStyles.Left
            };

            var filterComboBox = new ComboBox
            {
                Name = "filterComboBox",
                DropDownStyle = ComboBoxStyle.DropDownList,
                Location = new Point(filterLabel.Right + 5, 5),
                Width = 250, // Adjust width as needed
                Anchor = AnchorStyles.Left
            };

            // Use KeyValuePair to store both name and definition
            var filterItems = new List<object> { ClearFilterText }; // Add "No Filter" option
            filterItems.AddRange(_tableConfig.Filters
                                     .OrderBy(f => f.Value.Label)
                                     .Select(kvp => new KeyValuePair<string, FilterDefinition>(kvp.Key, kvp.Value))
                                     .Cast<object>()
                                     .ToList());

            filterComboBox.DataSource = filterItems;
            filterComboBox.DisplayMember = "Value.Label"; // Display the Label property of FilterDefinition
            filterComboBox.ValueMember = "Key"; // Use the filter name as the value

            // Handle display for the "Clear Filter" string item
            filterComboBox.Format += (s, e) => {
                if (e.ListItem is KeyValuePair<string, FilterDefinition> kvp)
                {
                    e.Value = kvp.Value.Label;
                }
                else if (e.ListItem is string str)
                {
                    e.Value = str; // Display the string itself ("-- No Filter --")
                }
            };


            // Set default filter if specified
            if (!string.IsNullOrEmpty(_tableConfig.DefaultFilterName) && _tableConfig.Filters.ContainsKey(_tableConfig.DefaultFilterName))
            {
                 var defaultItem = filterItems.OfType<KeyValuePair<string, FilterDefinition>>()
                                             .FirstOrDefault(kvp => kvp.Key.Equals(_tableConfig.DefaultFilterName, StringComparison.OrdinalIgnoreCase));
                 if (defaultItem.Key != null) // Check if found
                 {
                     filterComboBox.SelectedItem = defaultItem;
                 }
                 else filterComboBox.SelectedItem = ClearFilterText; // Fallback
            }
            else
            {
                filterComboBox.SelectedItem = ClearFilterText; // Default to "No Filter"
            }


            filterComboBox.SelectedIndexChanged += filterChangedHandler;

            _filterPanel.Controls.Add(filterLabel);
            _filterPanel.Controls.Add(filterComboBox);
        }
    }
}

---
.\UI\Builders\RelatedTabsBuilder.cs
---
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Windows.Forms;
using DynamicSqlEditor.Configuration.Models;
using DynamicSqlEditor.DataAccess;
using DynamicSqlEditor.Schema.Models;

namespace DynamicSqlEditor.UI.Builders
{
    public class RelatedTabsBuilder
    {
        private readonly TabControl _tabControl;
        private readonly TableSchema _parentTableSchema;
        private readonly TableConfig _parentTableConfig;
        private readonly DatabaseManager _dbManager; // Needed for schema lookups if necessary

        public RelatedTabsBuilder(TabControl tabControl, TableSchema parentTableSchema, TableConfig parentTableConfig, DatabaseManager dbManager)
        {
            _tabControl = tabControl ?? throw new ArgumentNullException(nameof(tabControl));
            _parentTableSchema = parentTableSchema ?? throw new ArgumentNullException(nameof(parentTableSchema));
            _parentTableConfig = parentTableConfig ?? throw new ArgumentNullException(nameof(parentTableConfig));
            _dbManager = dbManager ?? throw new ArgumentNullException(nameof(dbManager));
        }

        public void BuildTabs()
        {
            // Remove existing related tabs (keep index 0 - Details)
            while (_tabControl.TabPages.Count > 1)
            {
                _tabControl.TabPages.RemoveAt(1);
            }

            var relations = GetRelationsToDisplay();

            foreach (var relation in relations)
            {
                var tabPage = new TabPage(relation.Label)
                {
                    Tag = relation // Store the definition for later data loading
                };

                var relatedGrid = new DataGridView
                {
                    Dock = DockStyle.Fill,
                    AllowUserToAddRows = false,
                    AllowUserToDeleteRows = false,
                    ReadOnly = true,
                    AutoSizeColumnsMode = DataGridViewAutoSizeColumnsMode.DisplayedCells,
                    Name = $"relatedGrid_{relation.RelationName}" // Unique name
                };

                tabPage.Controls.Add(relatedGrid);
                _tabControl.TabPages.Add(tabPage);
            }
        }

        private List<RelatedChildDefinition> GetRelationsToDisplay()
        {
            var relations = new List<RelatedChildDefinition>();
            var relationNames = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

            // 1. Add explicitly configured relations
            foreach (var kvp in _parentTableConfig.RelatedChildren)
            {
                if (relationNames.Add(kvp.Key)) // Avoid duplicates if config has same name twice
                {
                    // Use RelationName from config key
                    kvp.Value.RelationName = kvp.Key;
                    relations.Add(kvp.Value);
                }
            }

            // 2. Add discovered relations (FKs in other tables referencing this table's PK)
            // Avoid adding if a relation with the same ChildTable/ChildFKColumn is already configured
            foreach (var fk in _parentTableSchema.ReferencedByForeignKeys)
            {
                // Check if this relationship is already covered by config (based on child table and FK column)
                bool alreadyConfigured = relations.Any(r =>
                    r.ChildTable.Equals($"{fk.ReferencingTable.SchemaName}.{fk.ReferencingTable.TableName}", StringComparison.OrdinalIgnoreCase) &&
                    r.ChildFKColumn.Equals(fk.ReferencingColumn.ColumnName, StringComparison.OrdinalIgnoreCase));

                if (!alreadyConfigured)
                {
                    // Generate a default label and relation name
                    string relationName = $"FK_{fk.ReferencingTable.TableName}_{fk.ReferencingColumn.ColumnName}";
                    if (relationNames.Add(relationName)) // Ensure unique name
                    {
                         relations.Add(new RelatedChildDefinition
                         {
                             RelationName = relationName,
                             Label = fk.ReferencingTable.TableName, // Default label is child table name
                             ChildTable = $"{fk.ReferencingTable.SchemaName}.{fk.ReferencingTable.TableName}",
                             ChildFKColumn = fk.ReferencingColumn.ColumnName,
                             ParentPKColumn = fk.ReferencedColumn.ColumnName // The PK column in the parent table
                         });
                    }
                }
            }

            // Could add sorting here if needed, e.g., alphabetically by Label
            return relations.OrderBy(r => r.Label).ToList();
        }
    }
}

---
.\UI\Controls\NullableDateTimePicker.cs
---
using System;
using System.ComponentModel;
using System.Windows.Forms;

namespace DynamicSqlEditor.UI.Controls
{
    public class NullableDateTimePicker : DateTimePicker
    {
        private DateTimePickerFormat _originalFormat = DateTimePickerFormat.Short;
        private string _originalCustomFormat = null;
        private bool _isNull = false;

        public NullableDateTimePicker() : base()
        {
            base.Format = DateTimePickerFormat.Custom;
            UpdateFormat();
        }

        [Browsable(true)]
        [Category("Behavior")]
        [Description("The DateTime value assigned to the control. Null if no date is selected.")]
        public new DateTime? Value
        {
            get { return _isNull ? (DateTime?)null : base.Value; }
            set
            {
                if (value == null)
                {
                    if (!_isNull) // Only update if changing state
                    {
                        _isNull = true;
                        _originalFormat = base.Format; // Store original format before changing
                        _originalCustomFormat = base.CustomFormat;
                        base.Format = DateTimePickerFormat.Custom;
                        base.CustomFormat = " "; // Display empty
                        OnValueChanged(EventArgs.Empty); // Notify change
                    }
                }
                else
                {
                    if (_isNull) // Restore format if was null
                    {
                         base.Format = _originalFormat;
                         base.CustomFormat = _originalCustomFormat;
                         _isNull = false;
                    }
                    base.Value = value.Value; // Set the actual value (will trigger base OnValueChanged)
                }
            }
        }

        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public new DateTimePickerFormat Format
        {
            get { return _originalFormat; }
            set
            {
                if (_originalFormat != value)
                {
                    _originalFormat = value;
                    if (!_isNull) // Apply immediately if not null
                    {
                        base.Format = value;
                        UpdateFormat();
                    }
                }
            }
        }

        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public new string CustomFormat
        {
            get { return _originalCustomFormat; }
            set
            {
                 if (_originalCustomFormat != value)
                 {
                     _originalCustomFormat = value;
                     if (!_isNull) // Apply immediately if not null
                     {
                         base.CustomFormat = value;
                         UpdateFormat();
                     }
                 }
            }
        }


        protected override void OnKeyDown(KeyEventArgs e)
        {
            base.OnKeyDown(e);
            if (e.KeyCode == Keys.Delete)
            {
                this.Value = null; // Set to null on Delete key press
            }
        }

        protected override void OnValueChanged(EventArgs eventargs)
        {
            // This override ensures that when the user picks a date (changing from null state),
            // the format is restored correctly before the base ValueChanged event fires.
            if (_isNull)
            {
                 base.Format = _originalFormat;
                 base.CustomFormat = _originalCustomFormat;
                 _isNull = false;
            }
            base.OnValueChanged(eventargs);
        }

        private void UpdateFormat()
        {
            if (base.Format == DateTimePickerFormat.Custom && string.IsNullOrWhiteSpace(base.CustomFormat))
            {
                base.CustomFormat = System.Globalization.CultureInfo.CurrentCulture.DateTimeFormat.ShortDatePattern;
            }
        }
    }
}

---
.\UI\Controls\PagingControl.cs
---
using System;
using System.ComponentModel;
using System.Windows.Forms;

namespace DynamicSqlEditor.UI.Controls
{
    public partial class PagingControl : UserControl
    {
        public event EventHandler FirstPageClicked;
        public event EventHandler PreviousPageClicked;
        public event EventHandler NextPageClicked;
        public event EventHandler LastPageClicked;
        public event EventHandler<int> PageSizeChanged;

        private int _currentPage = 1;
        private int _totalPages = 0;
        private int _totalRecords = 0;
        private int _pageSize = 50;

        public PagingControl()
        {
            InitializeComponent();
            pageSizeComboBox.Items.AddRange(new object[] { 10, 25, 50, 100, 250, 500 });
            pageSizeComboBox.SelectedItem = _pageSize; // Set initial selection
            UpdateDisplay();
        }

        [DefaultValue(1)]
        public int CurrentPage
        {
            get => _currentPage;
            set { _currentPage = value; UpdateDisplay(); }
        }

        [DefaultValue(0)]
        public int TotalPages
        {
            get => _totalPages;
            set { _totalPages = value; UpdateDisplay(); }
        }

        [DefaultValue(0)]
        public int TotalRecords
        {
            get => _totalRecords;
            set { _totalRecords = value; UpdateDisplay(); }
        }

         [DefaultValue(50)]
        public int PageSize
        {
            get => _pageSize;
            set
            {
                if (_pageSize != value)
                {
                    _pageSize = value;
                    // Update ComboBox selection if value changes programmatically
                    if (!pageSizeComboBox.Items.Contains(_pageSize))
                    {
                        // Optionally add it if not present, or select closest?
                        // For now, just ensure it's reflected internally.
                    }
                     else
                    {
                        pageSizeComboBox.SelectedItem = _pageSize;
                    }
                    UpdateDisplay();
                    // Note: PageSizeChanged event is fired by ComboBox event handler
                }
            }
        }

        public void UpdatePagingInfo(int currentPage, int totalPages, int totalRecords, int pageSize)
        {
            _currentPage = currentPage;
            _totalPages = totalPages;
            _totalRecords = totalRecords;
            _pageSize = pageSize;

            // Update ComboBox selection without firing event
            pageSizeComboBox.SelectedIndexChanged -= PageSizeComboBox_SelectedIndexChanged;
            if (!pageSizeComboBox.Items.Contains(_pageSize))
            {
                 // Handle case where current page size isn't in the list (e.g., from config)
                 // Maybe add it temporarily? Or just display it? For now, do nothing.
                 // pageSizeComboBox.Text = _pageSize.ToString(); // Display if not in list
            }
            else
            {
                 pageSizeComboBox.SelectedItem = _pageSize;
            }
            pageSizeComboBox.SelectedIndexChanged += PageSizeComboBox_SelectedIndexChanged;

            UpdateDisplay();
        }


        private void UpdateDisplay()
        {
            if (this.InvokeRequired)
            {
                this.Invoke(new Action(UpdateDisplay));
                return;
            }

            pageInfoLabel.Text = $"Page {_currentPage} of {_totalPages} ({_totalRecords} records)";
            btnFirst.Enabled = _currentPage > 1;
            btnPrevious.Enabled = _currentPage > 1;
            btnNext.Enabled = _currentPage < _totalPages;
            btnLast.Enabled = _currentPage < _totalPages;
        }

        private void BtnFirst_Click(object sender, EventArgs e) => FirstPageClicked?.Invoke(this, EventArgs.Empty);
        private void BtnPrevious_Click(object sender, EventArgs e) => PreviousPageClicked?.Invoke(this, EventArgs.Empty);
        private void BtnNext_Click(object sender, EventArgs e) => NextPageClicked?.Invoke(this, EventArgs.Empty);
        private void BtnLast_Click(object sender, EventArgs e) => LastPageClicked?.Invoke(this, EventArgs.Empty);

        private void PageSizeComboBox_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (pageSizeComboBox.SelectedItem != null && int.TryParse(pageSizeComboBox.SelectedItem.ToString(), out int newSize))
            {
                if (_pageSize != newSize)
                {
                    _pageSize = newSize;
                    PageSizeChanged?.Invoke(this, newSize);
                    // UpdateDisplay will be called after data reloads
                }
            }
        }

        #region Designer Code
        private System.Windows.Forms.Button btnFirst;
        private System.Windows.Forms.Button btnPrevious;
        private System.Windows.Forms.Label pageInfoLabel;
        private System.Windows.Forms.Button btnNext;
        private System.Windows.Forms.Button btnLast;
        private System.Windows.Forms.ComboBox pageSizeComboBox;
        private System.Windows.Forms.Label pageSizeLabel;
        private System.Windows.Forms.FlowLayoutPanel flowLayoutPanel1;

        private void InitializeComponent()
        {
            this.btnFirst = new System.Windows.Forms.Button();
            this.btnPrevious = new System.Windows.Forms.Button();
            this.pageInfoLabel = new System.Windows.Forms.Label();
            this.btnNext = new System.Windows.Forms.Button();
            this.btnLast = new System.Windows.Forms.Button();
            this.pageSizeComboBox = new System.Windows.Forms.ComboBox();
            this.pageSizeLabel = new System.Windows.Forms.Label();
            this.flowLayoutPanel1 = new System.Windows.Forms.FlowLayoutPanel();
            this.flowLayoutPanel1.SuspendLayout();
            this.SuspendLayout();
            //
            // btnFirst
            //
            this.btnFirst.Location = new System.Drawing.Point(3, 3);
            this.btnFirst.Name = "btnFirst";
            this.btnFirst.Size = new System.Drawing.Size(30, 23);
            this.btnFirst.TabIndex = 0;
            this.btnFirst.Text = "|<";
            this.btnFirst.UseVisualStyleBackColor = true;
            this.btnFirst.Click += new System.EventHandler(this.BtnFirst_Click);
            //
            // btnPrevious
            //
            this.btnPrevious.Location = new System.Drawing.Point(39, 3);
            this.btnPrevious.Name = "btnPrevious";
            this.btnPrevious.Size = new System.Drawing.Size(30, 23);
            this.btnPrevious.TabIndex = 1;
            this.btnPrevious.Text = "<";
            this.btnPrevious.UseVisualStyleBackColor = true;
            this.btnPrevious.Click += new System.EventHandler(this.BtnPrevious_Click);
            //
            // pageInfoLabel
            //
            this.pageInfoLabel.Anchor = System.Windows.Forms.AnchorStyles.Left;
            this.pageInfoLabel.AutoSize = true;
            this.pageInfoLabel.Location = new System.Drawing.Point(75, 8);
            this.pageInfoLabel.Name = "pageInfoLabel";
            this.pageInfoLabel.Size = new System.Drawing.Size(115, 13);
            this.pageInfoLabel.TabIndex = 2;
            this.pageInfoLabel.Text = "Page 1 of 1 (0 records)";
            this.pageInfoLabel.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
            //
            // btnNext
            //
            this.btnNext.Location = new System.Drawing.Point(196, 3);
            this.btnNext.Name = "btnNext";
            this.btnNext.Size = new System.Drawing.Size(30, 23);
            this.btnNext.TabIndex = 3;
            this.btnNext.Text = ">";
            this.btnNext.UseVisualStyleBackColor = true;
            this.btnNext.Click += new System.EventHandler(this.BtnNext_Click);
            //
            // btnLast
            //
            this.btnLast.Location = new System.Drawing.Point(232, 3);
            this.btnLast.Name = "btnLast";
            this.btnLast.Size = new System.Drawing.Size(30, 23);
            this.btnLast.TabIndex = 4;
            this.btnLast.Text = ">|";
            this.btnLast.UseVisualStyleBackColor = true;
            this.btnLast.Click += new System.EventHandler(this.BtnLast_Click);
            //
            // pageSizeComboBox
            //
            this.pageSizeComboBox.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
            this.pageSizeComboBox.FormattingEnabled = true;
            this.pageSizeComboBox.Location = new System.Drawing.Point(333, 4); // Adjusted margin
            this.pageSizeComboBox.Margin = new System.Windows.Forms.Padding(10, 4, 3, 3); // Add left margin
            this.pageSizeComboBox.Name = "pageSizeComboBox";
            this.pageSizeComboBox.Size = new System.Drawing.Size(60, 21);
            this.pageSizeComboBox.TabIndex = 6;
            this.pageSizeComboBox.SelectedIndexChanged += new System.EventHandler(this.PageSizeComboBox_SelectedIndexChanged);
            //
            // pageSizeLabel
            //
            this.pageSizeLabel.Anchor = System.Windows.Forms.AnchorStyles.Left;
            this.pageSizeLabel.AutoSize = true;
            this.pageSizeLabel.Location = new System.Drawing.Point(275, 8); // Adjusted margin
            this.pageSizeLabel.Margin = new System.Windows.Forms.Padding(10, 0, 3, 0); // Add left margin
            this.pageSizeLabel.Name = "pageSizeLabel";
            this.pageSizeLabel.Size = new System.Drawing.Size(58, 13);
            this.pageSizeLabel.TabIndex = 5;
            this.pageSizeLabel.Text = "Page Size:";
            //
            // flowLayoutPanel1
            //
            this.flowLayoutPanel1.AutoSize = true;
            this.flowLayoutPanel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;
            this.flowLayoutPanel1.Controls.Add(this.btnFirst);
            this.flowLayoutPanel1.Controls.Add(this.btnPrevious);
            this.flowLayoutPanel1.Controls.Add(this.pageInfoLabel);
            this.flowLayoutPanel1.Controls.Add(this.btnNext);
            this.flowLayoutPanel1.Controls.Add(this.btnLast);
            this.flowLayoutPanel1.Controls.Add(this.pageSizeLabel);
            this.flowLayoutPanel1.Controls.Add(this.pageSizeComboBox);
            this.flowLayoutPanel1.Dock = System.Windows.Forms.DockStyle.Fill; // Fill the UserControl
            this.flowLayoutPanel1.Location = new System.Drawing.Point(0, 0);
            this.flowLayoutPanel1.Name = "flowLayoutPanel1";
            this.flowLayoutPanel1.Size = new System.Drawing.Size(400, 29); // Example size, will adjust
            this.flowLayoutPanel1.TabIndex = 7;
            this.flowLayoutPanel1.WrapContents = false; // Prevent wrapping
            //
            // PagingControl
            //
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.AutoSize = true;
            this.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;
            this.Controls.Add(this.flowLayoutPanel1);
            this.Margin = new System.Windows.Forms.Padding(0);
            this.Name = "PagingControl";
            this.Size = new System.Drawing.Size(400, 29); // Example size
            this.flowLayoutPanel1.ResumeLayout(false);
            this.flowLayoutPanel1.PerformLayout();
            this.ResumeLayout(false);
            this.PerformLayout();
        }
        #endregion
    }
}

---
.\UI\Dialogs\ConfirmationDialog.cs
---
using System;
using System.Windows.Forms;

namespace DynamicSqlEditor.UI.Dialogs
{
    // Simple wrapper if needed, otherwise use MessageBox directly.
    public static class ConfirmationDialog
    {
        public static DialogResult Show(string message, string caption = "Confirm", MessageBoxButtons buttons = MessageBoxButtons.YesNo, MessageBoxIcon icon = MessageBoxIcon.Question)
        {
            // Ensure dialog shows on top if called from non-UI thread context (though ideally UI calls are marshalled)
            Form topForm = Application.OpenForms.Count > 0 ? Application.OpenForms[Application.OpenForms.Count - 1] : null;
            return MessageBox.Show(topForm ?? new Form { TopMost = true }, message, caption, buttons, icon);
        }
    }
}

---
.\UI\Dialogs\FilterInputDialog.cs
---
// File: DynamicSqlEditor/UI/Dialogs/FilterInputDialog.cs
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Drawing;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Forms;
using DynamicSqlEditor.Common;
using DynamicSqlEditor.Configuration.Models;
// Removed: using DynamicSqlEditor.Core; // Can remove if using fully qualified names

namespace DynamicSqlEditor.UI.Dialogs
{
    public partial class FilterInputDialog : Form
    {
        private readonly FilterDefinition _filter;
        // Use fully qualified name for the field
        private readonly DynamicSqlEditor.Core.DataViewManager _dataViewManager;
        private readonly Dictionary<string, Control> _inputControls = new Dictionary<string, Control>();

        // Use fully qualified name for the constructor parameter
        public FilterInputDialog(FilterDefinition filter, DynamicSqlEditor.Core.DataViewManager dataViewManager)
        {
            InitializeComponent();
            _filter = filter ?? throw new ArgumentNullException(nameof(filter));
            _dataViewManager = dataViewManager ?? throw new ArgumentNullException(nameof(dataViewManager)); // Assign the correct type
            this.Text = $"Input for Filter: {filter.Label}";

            BuildInputControls();
        }

        private void BuildInputControls()
        {
            var tableLayout = new TableLayoutPanel
            {
                Dock = DockStyle.Fill,
                AutoSize = true,
                ColumnCount = 2,
                Padding = new Padding(10)
            };
            tableLayout.ColumnStyles.Add(new ColumnStyle(SizeType.AutoSize));
            tableLayout.ColumnStyles.Add(new ColumnStyle(SizeType.Percent, 100F));

            string[] requiredParams = _filter.RequiresInput.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);

            foreach (string reqParamInfo in requiredParams)
            {
                string paramName = reqParamInfo.Trim();
                string lookupType = null;
                if (paramName.Contains(":"))
                {
                    var parts = paramName.Split(':');
                    paramName = parts[0].Trim();
                    lookupType = parts[1].Trim();
                }

                Label label = new Label { Text = paramName + ":", AutoSize = true, Margin = new Padding(3, 6, 3, 3) };
                Control inputControl;

                if (!string.IsNullOrEmpty(lookupType))
                {
                    // Assume lookupType corresponds to a TableConfig FKLookup definition name or a table name
                    var comboBox = new ComboBox { Name = paramName, DropDownStyle = ComboBoxStyle.DropDownList, Width = 200, Anchor = AnchorStyles.Left | AnchorStyles.Right };
                    inputControl = comboBox;
                    // Load lookup data asynchronously after form is shown
                    this.Shown += async (s, e) => await LoadLookupDataAsync(comboBox, lookupType);
                }
                else
                {
                    // Default to TextBox for non-lookup inputs
                    inputControl = new TextBox { Name = paramName, Width = 200, Anchor = AnchorStyles.Left | AnchorStyles.Right };
                }
                inputControl.Margin = new Padding(3);

                tableLayout.RowCount++;
                tableLayout.RowStyles.Add(new RowStyle(SizeType.AutoSize));
                tableLayout.Controls.Add(label, 0, tableLayout.RowCount - 1);
                tableLayout.Controls.Add(inputControl, 1, tableLayout.RowCount - 1);

                _inputControls.Add(paramName, inputControl);
            }

            // Add button panel below the table layout
            tableLayout.RowCount++;
            tableLayout.RowStyles.Add(new RowStyle(SizeType.Absolute, buttonPanel.Height + 10)); // Add space for buttons
            tableLayout.Controls.Add(buttonPanel, 0, tableLayout.RowCount - 1);
            tableLayout.SetColumnSpan(buttonPanel, 2); // Span buttons across both columns
            buttonPanel.Dock = DockStyle.Fill; // Make button panel fill its cell


            this.Controls.Add(tableLayout);
            // Adjust form size based on content
            this.ClientSize = new Size(350, tableLayout.GetPreferredSize(new Size(350, 0)).Height + 10); // Calculate preferred height
            this.MinimumSize = new Size(300, this.ClientSize.Height); // Set minimum size
        }

        private async Task LoadLookupDataAsync(ComboBox comboBox, string lookupType)
        {
            // Find FKLookup definition matching the lookupType (could be FK column name or custom name)
            // This requires searching through TableConfigs - might need access to StateManager or pass more context.
            // Simplified: Assume lookupType is directly a ReferencedTable name (Schema.Table) for now.
            // A real implementation needs a way to resolve lookupType to a FKLookupDefinition.

            // Placeholder: Assume lookupType is "Schema.TableName"
            var pseudoLookupConfig = new FKLookupDefinition
            {
                // Need to guess Display/Value columns based on heuristics or require explicit config
                ReferencedTable = lookupType,
                DisplayColumn = await FindBestDisplayColumnHeuristicAsync(lookupType), // Needs heuristic logic
                ValueColumn = await GetPrimaryKeyColumnNameAsync(lookupType) // Needs PK lookup
            };

            if (string.IsNullOrEmpty(pseudoLookupConfig.DisplayColumn) || string.IsNullOrEmpty(pseudoLookupConfig.ValueColumn))
            {
                FileLogger.Error($"Cannot configure lookup ComboBox for filter parameter '{comboBox.Name}'. Could not determine Display/Value columns for '{lookupType}'.");
                comboBox.Items.Add("Lookup Error");
                comboBox.Enabled = false;
                return;
            }


            try
            {
                comboBox.Enabled = false; // Disable while loading
                comboBox.DataSource = null;
                comboBox.Items.Clear();
                comboBox.Items.Add("Loading...");
                comboBox.SelectedIndex = 0;

                DataTable lookupData = await _dataViewManager.GetLookupDataAsync(pseudoLookupConfig);

                comboBox.DataSource = lookupData;
                comboBox.DisplayMember = pseudoLookupConfig.DisplayColumn;
                comboBox.ValueMember = pseudoLookupConfig.ValueColumn;
                comboBox.SelectedIndex = -1;
                // comboBox.Items.Remove("Loading..."); // Remove placeholder if DataSource is used - DataSource replaces Items
                comboBox.Enabled = true;
            }
            catch (Exception ex)
            {
                FileLogger.Error($"Failed to load lookup data for filter parameter '{comboBox.Name}' (LookupType: {lookupType})", ex);
                comboBox.DataSource = null;
                comboBox.Items.Clear();
                comboBox.Items.Add("Load Error");
                comboBox.Enabled = false;
            }
        }

        // Helper methods duplicated from DetailFormBuilder - need centralization
        // These helpers now rely on _dataViewManager which is the correct type
        private async Task<string> FindBestDisplayColumnHeuristicAsync(string fullTableName)
        {
            // Needs access to GlobalConfig heuristics and schema provider/cache
            // Placeholder implementation
            var heuristics = Constants.DefaultFKHeuristic.Split(',').ToList(); // Use default constant
                                                                               // Need schema for fullTableName...
                                                                               // For now, just return "Name" as a guess
                                                                               // A better approach would involve getting the TableSchema via StateManager
            return "Name"; // VERY basic placeholder
        }
        private async Task<string> GetPrimaryKeyColumnNameAsync(string fullTableName)
        {
            try
            {
                string query = @"
                    SELECT TOP 1 COLUMN_NAME
                    FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE
                    WHERE OBJECTPROPERTY(OBJECT_ID(CONSTRAINT_SCHEMA + '.' + QUOTENAME(CONSTRAINT_NAME)), 'IsPrimaryKey') = 1
                    AND TABLE_SCHEMA = PARSENAME(@TableName, 2) AND TABLE_NAME = PARSENAME(@TableName, 1);";
                var param = SqlParameterHelper.CreateParameter("@TableName", fullTableName);
                // Access DbManager via the correctly typed _dataViewManager
                object result = await _dataViewManager.DbManager.ExecuteScalarAsync(query, new List<SqlParameter> { param });
                return result?.ToString();
            }
            catch (Exception ex)
            {
                FileLogger.Error($"Failed to get primary key for table {fullTableName} during filter dialog setup", ex);
                return null;
            }
        }


        public Dictionary<string, object> GetInputValues()
        {
            var values = new Dictionary<string, object>();
            foreach (var kvp in _inputControls)
            {
                string paramName = kvp.Key;
                Control control = kvp.Value;
                object value = null;

                if (control is TextBox txt) value = txt.Text;
                else if (control is ComboBox cmb) value = cmb.SelectedValue; // Use SelectedValue
                // Add other control types if needed

                values.Add(paramName, value ?? DBNull.Value); // Use DBNull if value is null
            }
            return values;
        }

        private void okButton_Click(object sender, EventArgs e)
        {
            // Basic validation: Ensure required fields are filled
            foreach (var kvp in _inputControls)
            {
                Control control = kvp.Value;
                bool isEmpty = false;
                if (control is TextBox txt && string.IsNullOrWhiteSpace(txt.Text)) isEmpty = true;
                else if (control is ComboBox cmb && cmb.SelectedIndex == -1) isEmpty = true;

                if (isEmpty)
                {
                    MessageBox.Show($"Please provide a value for '{kvp.Key}'.", "Input Required", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                    control.Focus();
                    return; // Prevent closing dialog
                }
            }

            this.DialogResult = DialogResult.OK;
            this.Close();
        }

        private void cancelButton_Click(object sender, EventArgs e)
        {
            this.DialogResult = DialogResult.Cancel;
            this.Close();
        }

        #region Designer Code
        private System.ComponentModel.IContainer components = null;
        private System.Windows.Forms.Button okButton;
        private System.Windows.Forms.Button cancelButton;
        private System.Windows.Forms.Panel buttonPanel;

        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        private void InitializeComponent()
        {
            this.okButton = new System.Windows.Forms.Button();
            this.cancelButton = new System.Windows.Forms.Button();
            this.buttonPanel = new System.Windows.Forms.Panel();
            this.buttonPanel.SuspendLayout();
            this.SuspendLayout();
            //
            // okButton
            //
            this.okButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
            this.okButton.Location = new System.Drawing.Point(172, 10);
            this.okButton.Name = "okButton";
            this.okButton.Size = new System.Drawing.Size(75, 23);
            this.okButton.TabIndex = 0;
            this.okButton.Text = "OK";
            this.okButton.UseVisualStyleBackColor = true;
            this.okButton.Click += new System.EventHandler(this.okButton_Click);
            //
            // cancelButton
            //
            this.cancelButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
            this.cancelButton.DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this.cancelButton.Location = new System.Drawing.Point(253, 10);
            this.cancelButton.Name = "cancelButton";
            this.cancelButton.Size = new System.Drawing.Size(75, 23);
            this.cancelButton.TabIndex = 1;
            this.cancelButton.Text = "Cancel";
            this.cancelButton.UseVisualStyleBackColor = true;
            this.cancelButton.Click += new System.EventHandler(this.cancelButton_Click);
            //
            // buttonPanel
            //
            this.buttonPanel.Controls.Add(this.okButton);
            this.buttonPanel.Controls.Add(this.cancelButton);
            this.buttonPanel.Dock = System.Windows.Forms.DockStyle.Bottom; // Will be placed in TableLayoutPanel cell
            this.buttonPanel.Location = new System.Drawing.Point(0, 0); // Positioned by TableLayoutPanel
            this.buttonPanel.MinimumSize = new System.Drawing.Size(0, 45);
            this.buttonPanel.Name = "buttonPanel";
            this.buttonPanel.Size = new System.Drawing.Size(340, 45);
            this.buttonPanel.TabIndex = 2;
            //
            // FilterInputDialog
            //
            this.AcceptButton = this.okButton;
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.AutoSize = true; // Allow form to resize based on content
            this.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;
            this.CancelButton = this.cancelButton;
            this.ClientSize = new System.Drawing.Size(340, 100); // Initial size, will be adjusted
            // Controls added dynamically in BuildInputControls
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = "FilterInputDialog";
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
            this.Text = "Filter Input";
            this.buttonPanel.ResumeLayout(false);
            this.ResumeLayout(false);
            this.PerformLayout(); // Ensure AutoSize works correctly

        }
        #endregion
    }
}

---
